// Consolidated sources from: /home/devvi/opt/personal-projects/gemini-poc
// Consolidation timestamp: 2025-04-14 11:30:43
// Tool Name: gemini-poc (inspector module)
// Root Directory: /home/devvi/opt/personal-projects/gemini-poc
// Include Extensions: .env, .js, .json, .ts
// Exclude Patterns/Files: .git, README.md, build, code.extractor.ts, consolidated_output.txt, consolidated_sources.ts, coverage, dist, docs.md, node_modules, package-lock.json

// File: package.json

{
  "name": "gemini-poc",
  "version": "1.0.0",
  "description": "Proof of concept using Google Gemini API for code tasks",
  "type": "module",
  "main": "dist/app.js",
  "scripts": {
    "clean": "rimraf ./dist",
    "build": "npm run clean && tsc",
    "start": "node dist/index.js",
    "dev": "tsx src/index.ts",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "gemini",
    "ai",
    "typescript",
    "poc"
  ],
  "author": "Your Name",
  "license": "ISC",
  "dependencies": {
    "axios": "^1.7.2",
    "dotenv": "^16.4.5",
    "p-limit": "^5.0.0",
    "yargs": "^17.7.2"
  },
  "devDependencies": {
    "@types/axios": "^0.14.0",
    "@types/node": "^20.12.12",
    "@types/yargs": "^17.0.33",
    "rimraf": "^5.0.7",
    "ts-node": "^10.9.2",
    "tsx": "^4.10.5",
    "typescript": "^5.4.5"
  }

// File: src/config/app.config.ts

import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

// Handle ESM paths for dotenv
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
// Load .env from project root (assuming config is in src/config)
dotenv.config({ path: path.resolve(__dirname, '../../.env') });


// --- Required API Key ---
/**
 * The Gemini API key.
 * This is a required environment variable.
 * @throws {Error} If the GEMINI_API_KEY environment variable is not set.
 */
export const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

if (!GEMINI_API_KEY) {
    console.error("CRITICAL ERROR: GEMINI_API_KEY environment variable not found.");
    console.log("Please create a .env file in the project root and add your API key:");
    console.log("GEMINI_API_KEY=YOUR_API_KEY_HERE");
    process.exit(1);
}

// --- Selectable Model Name ---
const DEFAULT_GEMINI_MODEL = 'gemini-1.5-flash-latest';
/**
 * The Gemini model name to use.
 * Defaults to 'gemini-1.5-flash-latest' if the GEMINI_MODEL_NAME environment variable is not set.
 */
export const GEMINI_MODEL_NAME = process.env.GEMINI_MODEL_NAME || DEFAULT_GEMINI_MODEL;

// --- Construct Endpoint Dynamically ---
// Base URL structure for the generateContent method
const GEMINI_API_BASE = `https://generativelanguage.googleapis.com/v1beta/models`;
/**
 * The full Gemini API endpoint URL.
 * This is constructed dynamically using the GEMINI_API_BASE and GEMINI_MODEL_NAME.
 */
export const GEMINI_API_ENDPOINT = `${GEMINI_API_BASE}/${GEMINI_MODEL_NAME}:generateContent`; // Construct the full endpoint URL


// --- Log Loaded Configuration ---
// Moved logging to where config is first imported (e.g., gemini.service) to avoid top-level side effects
console.log("Configuration loaded.");
console.log(` > Using Gemini Model: ${GEMINI_MODEL_NAME}`);
console.log(` > Gemini Endpoint: ${GEMINI_API_ENDPOINT}`);

// File: src/gemini/cli/gemini.cli.ts

// src/gemini/cli/gemini.cli.ts
import yargs, { Argv } from 'yargs';
import { hideBin } from 'yargs/helpers';
// Corrected: Import the *specific types* needed, not the union directly here if only using EnhancementType
import { CliArguments } from '../../shared/types/app.type.js';
import { runCommandLogic } from './gemini.handler.js';
import { EnhancementType } from '../../shared/enums/enhancement.type.js';

const logPrefix = "[GeminiCLI]";

/**
 * Sets up common options (targetPath, prefix) for yargs commands (used by EnhancementType commands).
 * @param yargsInstance The yargs instance to configure.
 * @returns The yargs instance with the added options.
 */
const setupDefaultCommand = (yargsInstance: Argv<{}>): Argv<{ targetPath: string; prefix: string | undefined }> => {
    return yargsInstance
        .positional('targetPath', {
            describe: 'Target file or directory path',
            type: 'string',
            demandOption: true, // targetPath is always required
        })
        .option('prefix', {
            alias: 'p',
            type: 'string',
            description: 'Optional filename prefix filter for directory processing',
            demandOption: false, // prefix is optional
        });
};

/**
 * Configures and runs the yargs CLI parser.
 * This function defines the commands, options, and logic for the Gemini CLI.
 * @param processArgs The arguments passed to the process, typically process.argv.
 * @returns A Promise that resolves when the CLI execution is complete.
 * @throws An error if argument parsing or command execution fails.
 */
export async function runCli(processArgs: string[]): Promise<void> {
    console.log(`${logPrefix} Initializing...`);

    await yargs(hideBin(processArgs))
        // --- EnhancementType Commands ---
        .command( // AddComments
            `${EnhancementType.AddComments} <targetPath>`,
            'Add AI-generated comments to files.',
            setupDefaultCommand,
            (argv) => runCommandLogic({ ...argv, command: EnhancementType.AddComments } as CliArguments)
        )
        .command( // Analyze
            `${EnhancementType.Analyze} <targetPath>`,
            'Analyze code structure and quality.',
            setupDefaultCommand,
            (argv) => runCommandLogic({ ...argv, command: EnhancementType.Analyze } as CliArguments)
        )
        .command( // Explain
            `${EnhancementType.Explain} <targetPath>`,
            'Explain what the code does.',
            setupDefaultCommand,
            (argv) => runCommandLogic({ ...argv, command: EnhancementType.Explain } as CliArguments)
        )
        .command( // AddPathComment
            `${EnhancementType.AddPathComment} <targetPath>`,
            'Add "// File: <relativePath>" comment header to files.',
            setupDefaultCommand,
            (argv) => runCommandLogic({ ...argv, command: EnhancementType.AddPathComment } as CliArguments)
        )
        .command( // Consolidate
            `${EnhancementType.Consolidate} <targetPath>`,
            'Consolidate code into a single output file (consolidated_output.txt).',
            setupDefaultCommand,
            (argv) => runCommandLogic({ ...argv, command: EnhancementType.Consolidate } as CliArguments)
        )
        .command( // SuggestImprovements
            `${EnhancementType.SuggestImprovements} <targetPath>`,
            'Suggest improvements for the code.',
            setupDefaultCommand,
            (argv) => runCommandLogic({ ...argv, command: EnhancementType.SuggestImprovements } as CliArguments)
        )
        .command( // GenerateDocs
            `${EnhancementType.GenerateDocs} <targetPath>`,
            'Generate Markdown documentation (saves to README.md).',
            setupDefaultCommand,
            (argv) => runCommandLogic({ ...argv, command: EnhancementType.GenerateDocs } as CliArguments)
        )
        .command( // InferFromData
            `${EnhancementType.InferFromData} <targetPath>`,
            'Infer TypeScript interface from a JSON data file.',
            (yargsInstance) => {
                return yargsInstance
                    .positional('targetPath', {
                        describe: 'Path to the JSON data file',
                        type: 'string',
                        demandOption: true,
                    })
                    .option('interfaceName', {
                        alias: 'i',
                        type: 'string',
                        description: 'Name for the generated TypeScript interface',
                        demandOption: true,
                    });
            },
            (argv) => runCommandLogic({ ...argv, command: EnhancementType.InferFromData } as CliArguments)
        )
        // --- GenerateStructureDoc Command ---
        .command(
            `${EnhancementType.GenerateStructureDoc} [targetPath]`, // Use enum value
            'Generate a Markdown file representing the project directory structure.',
            (yargsInstance) => { // Builder defines specific options
                return yargsInstance
                    .positional('targetPath', {
                        describe: 'Root directory to scan.',
                        type: 'string',
                        default: './src',
                    })
                    .option('output', {
                        alias: 'o',
                        type: 'string',
                        description: 'Path for the output Markdown file.',
                        default: 'Project Tree Structure.md',
                    })
                    .option('descriptions', {
                        alias: 'd',
                        type: 'boolean',
                        description: 'Include standard descriptions for known directories.',
                        default: false,
                    })
                    .option('depth', {
                        alias: 'L',
                        type: 'number',
                        description: 'Maximum directory depth to display.',
                    })
                    .option('exclude', {
                        alias: 'e',
                        type: 'string',
                        description: 'Comma-separated list of additional names/patterns to exclude.',
                        default: '',
                    });
            },
            // Pass the correct enum value to the handler
            (argv) => runCommandLogic({ ...argv, command: EnhancementType.GenerateStructureDoc } as CliArguments) // Use unified type
        )
        // --- End New Command ---
        .demandCommand(1, 'Please specify a valid command (action).')
        .strict()
        .help()
        .alias('h', 'help')
        .wrap(null)
        .fail((msg, err, yargs) => {
            if (err) {
                console.error(`\n${logPrefix} 🚨 An unexpected error occurred during argument parsing:`);
                console.error(err);
                process.exit(1);
            }
            console.error(`\n${logPrefix} ❌ Error: ${msg}\n`);
            yargs.showHelp();
            process.exit(1);
        })
        .parseAsync()
        .catch(error => {
            console.error(`\n${logPrefix} 🚨 An unexpected critical error occurred during execution:`);
            if (error instanceof Error) {
                console.error(`   Message: ${error.message}`);
                console.error(error.stack);
            } else {
                console.error("   An unknown error object was thrown:", error);
            }
            process.exit(1);
        });
}

// File: src/gemini/cli/gemini.handler.ts

// src/gemini/cli/gemini.handler.ts
import * as fs from 'fs';
import * as path from 'path';
import pLimit from 'p-limit';
import { EXCLUDE_PATTERNS, EXCLUDE_FILENAMES } from '../../shared/constants/filesystem.constants.js';
import { inferTypesFromData } from '../../shared/helpers/type-inference.helper.js';
import { CliArguments, FileProcessingResult } from '../../shared/types/app.type.js'; // Unified type
import { EnhancementType } from '../../shared/enums/enhancement.type.js'; // Enum
import { getConsolidatedSources, getTargetFiles } from '../../shared/utils/filesystem.utils.js';
import { readSingleFile, updateFileContent, writeOutputFile } from '../../shared/utils/file-io.utils.js';
import { enhanceCodeWithGemini, GeminiEnhancementResult } from '../gemini.service.js';

const logPrefix = "[GeminiHandler]";

// --- Standard Directory Descriptions (Unchanged) ---
const standardDescriptions: ReadonlyMap<string, string> = new Map([
    /* ... descriptions ... */
    ['cli', '# CLI specific logic (commands, handlers)'],
    ['clients', '# Clients for external APIs/services'],
    ['config', '# Configuration loading and access'],
    ['constants', '# Shared constant values (magic strings, keys)'],
    ['controllers', '# Handles incoming requests (HTTP/RPC)'],
    ['database', '# Database connection, migrations, seeding orchestration'],
    ['decorators', '# Custom TypeScript decorators'],
    ['dtos', '# Data Transfer Objects (input/output shapes)'],
    ['entities', '# Domain models or DB schema definitions'],
    ['enums', '# Shared enumerations'],
    ['events', '# Event definitions'],
    ['exceptions', '# Custom error/exception classes'],
    ['fakes', '# Mock/stub implementations for testing'],
    ['guards', '# Authorization/authentication guards'],
    ['handlers', '# Event/message handlers/listeners'],
    ['helpers', '# General-purpose utility functions'],
    ['jobs', '# Background job definitions'],
    ['lib', '# Shared libraries or complex utilities'],
    ['middleware', '# Request/response middleware'],
    ['migrations', '# Database schema migration files'],
    ['policies', '# Complex authorization policies'],
    ['prompts', '# AI prompt templates'],
    ['repositories', '# Data access layer abstraction'],
    ['routes', '# API endpoint definitions'],
    ['schemas', '# Data validation schemas (Zod, Joi, etc.)'],
    ['seeders', '# Database seeding scripts'],
    ['serializers', '# Data transformation utilities'],
    ['services', '# Core business logic'],
    ['shared', '# Shared utilities, types, constants (top-level)'],
    ['shared-modules', '# Shared cross-cutting modules (logging, auth)'],
    ['tests', '# Unit, integration, e2e tests'],
    ['types', '# Shared TypeScript interfaces/types'],
    ['utils', '# Shared utility functions (often more specific than helpers)'],
    ['validators', '# Custom validation logic/rules'],
]);

// --- Define an interface for the options of generateTreeLines ---
interface GenerateTreeOptions {
    depth: number;
    maxDepth?: number;
    prefix: string;
    useDescriptions: boolean;
    exclusions: Set<string>;
}

// --- Recursive Tree Generation Function (Use the interface) ---
/**
 * Recursively scans a directory and generates formatted tree lines.
 */
async function generateTreeLines(
    currentPath: string,
    options: GenerateTreeOptions // <<< Use the named interface here
): Promise<string[]> {
    // Now destructuring works correctly because options has a clear type
    const { depth, maxDepth, prefix, useDescriptions, exclusions } = options;
    let outputLines: string[] = [];

    if (maxDepth !== undefined && depth > maxDepth) {
        return [];
    }

    let entries: string[];
    try {
        entries = await fs.promises.readdir(currentPath);
    } catch (error) {
        console.warn(`${logPrefix} ⚠️ Could not read directory ${currentPath}: ${error instanceof Error ? error.message : error}`);
        return [`${prefix}└── Error reading directory!`];
    }

    const filteredEntries = entries
        .filter(entry => !exclusions.has(entry))
        .sort((a, b) => { /* ... sorting logic ... */
            try {
                const statA = fs.statSync(path.join(currentPath, a));
                const statB = fs.statSync(path.join(currentPath, b));
                if (statA.isDirectory() && !statB.isDirectory()) return -1;
                if (!statA.isDirectory() && statB.isDirectory()) return 1;
            } catch { /* Ignore stat errors during sort */ }
            return a.localeCompare(b);
        });

    for (let i = 0; i < filteredEntries.length; i++) {
        const entry = filteredEntries[i];
        const entryPath = path.join(currentPath, entry);
        const isLastEntry = i === filteredEntries.length - 1;
        const connector = isLastEntry ? '└── ' : '├── ';
        const linePrefix = prefix + connector;

        let line = linePrefix + entry;
        let isDirectory = false;

        try {
            const stats = await fs.promises.stat(entryPath);
            isDirectory = stats.isDirectory();
            if (isDirectory) {
                line += '/';
                if (useDescriptions && standardDescriptions.has(entry)) {
                    line += ` ${standardDescriptions.get(entry)}`;
                }
            outputLines.push(line);

            if (isDirectory && (maxDepth === undefined || depth < maxDepth)) {
                const nextPrefix = prefix + (isLastEntry ? '    ' : '│   ');
                // Pass the options object matching the interface type for the recursive call
                const childLines = await generateTreeLines(entryPath, {
                    ...options, // Spread existing options
                    depth: depth + 1, // Override depth
                    prefix: nextPrefix, // Override prefix
                });
                outputLines = outputLines.concat(childLines);
            }
        } catch (statError) {
            outputLines.push(`${linePrefix}${entry} (Error: ${statError instanceof Error ? statError.message : 'Cannot stat'})`);
            console.warn(`${logPrefix} ⚠️ Could not stat ${entryPath}: ${statError instanceof Error ? statError.message : statError}`);
        }
    return outputLines;
}


// --- Main Command Handler ---
/**
 * The core application logic. Dispatches to appropriate handlers based on the command.
 * @param {CliArguments} argv The parsed arguments object from yargs.
 * @returns {Promise<void>} A promise that resolves when the command logic is complete.
 */
export async function runCommandLogic(argv: CliArguments): Promise<void> {
    const { command, targetPath } = argv; // Common arguments

    switch (command) {
        case EnhancementType.GenerateStructureDoc: {
            const { output, descriptions, depth, exclude } = argv;
            console.log(`\n${logPrefix} Executing action: ${command} on target: ${targetPath}`);
            const outputOrDefault = output || 'Project Tree Structure.md';
            const descriptionsOrDefault = descriptions || false;
            const excludeOrDefault = exclude || '';

            console.log(`  Outputting to: ${outputOrDefault}`);
            if (descriptionsOrDefault) console.log(`  Including descriptions.`);
            if (depth !== undefined) console.log(`  Max depth: ${depth}`);
            if (excludeOrDefault) console.log(`  Excluding: ${excludeOrDefault}`);

            try {
                const absTargetPath = path.resolve(targetPath);
                const absOutputPath = path.resolve(outputOrDefault);

                if (!fs.existsSync(absTargetPath) || !fs.statSync(absTargetPath).isDirectory()) {
                    console.error(`${logPrefix} ❌ Error: Target path '${targetPath}' does not exist or is not a directory.`);
                    process.exit(1);
                }

                const standardExclusions = new Set([...EXCLUDE_PATTERNS, ...EXCLUDE_FILENAMES]);
                const userExclusions = excludeOrDefault ? excludeOrDefault.split(',').map(s => s.trim()).filter(s => s) : [];
                userExclusions.forEach(ex => standardExclusions.add(ex));
                if (absOutputPath.startsWith(path.dirname(absTargetPath))) {
                    standardExclusions.add(path.basename(absOutputPath));
                }

                console.log(`${logPrefix} Scanning directory structure...`);
                // Explicitly create the options object matching the interface
                const treeOptions: GenerateTreeOptions = {
                    depth: 0,
                    maxDepth: depth, // Pass optional depth directly
                    prefix: '',
                    useDescriptions: descriptionsOrDefault,
                    exclusions: standardExclusions,
                };
                const treeLines = await generateTreeLines(absTargetPath, treeOptions); // Pass typed options

                const outputContent = `${path.basename(absTargetPath)}/\n` + treeLines.join('\n');
                const success = writeOutputFile(absOutputPath, outputContent);

                if (success) {
                    console.log(`\n${logPrefix} ✅ Successfully generated structure document: ${outputOrDefault}`);
                } else {
                    console.error(`${logPrefix} ❌ Failed to write structure document.`);
                    process.exitCode = 1;
                }

            } catch (error) {
                console.error(`\n${logPrefix} ❌ An unexpected error occurred during ${command}:`);
                if (error instanceof Error) {
                    console.error(`   Message: ${error.message}`);
                    console.error(error.stack);
                } else {
                    console.error("   Unknown error object:", error);
                }
                process.exit(1);
            }
            break; // Exit the switch case
        }

        // --- Cases for other EnhancementType commands ---
        // (The rest of the switch cases for AddComments, Analyze, etc. remain unchanged)
        case EnhancementType.AddComments:
        case EnhancementType.Analyze:
        case EnhancementType.Explain:
        case EnhancementType.AddPathComment:
        case EnhancementType.Consolidate:
        case EnhancementType.SuggestImprovements:
        case EnhancementType.GenerateDocs:
        case EnhancementType.InferFromData: {
            /* ... existing logic for these cases ... */
            // Destructure arguments relevant to these commands
            const { prefix, interfaceName } = argv;
            const action = command; // Use command directly as action
            const actionDetails = `${prefix ? ` with prefix: ${prefix}` : ''}${interfaceName ? ` (Interface: ${interfaceName})` : ''}`;
            console.log(`\n${logPrefix} Executing enhancement: ${action} on target: ${targetPath}${actionDetails}`);

            // --- Validation ---
            let stats: fs.Stats;
            try {
                stats = fs.statSync(targetPath);
                if (action === EnhancementType.InferFromData && !stats.isFile()) {
                    console.error(`\n${logPrefix} ❌ Error: Target path for '${EnhancementType.InferFromData}' must be a file (e.g., JSON).`);
                    process.exit(1);
                }
            } catch (e) {
                console.error(`\n${logPrefix} ❌ Error: Cannot access target path: ${targetPath}. Please ensure it exists.`);
                process.exit(1);
            }

            // --- Classify Action Type ---
            const isModificationAction = [EnhancementType.AddComments, EnhancementType.AddPathComment].includes(action);
            const usesGeminiApi = [EnhancementType.AddComments, EnhancementType.Analyze, EnhancementType.Explain, EnhancementType.SuggestImprovements, EnhancementType.GenerateDocs].includes(action);
            const isLocalProcessingAction = [EnhancementType.Consolidate, EnhancementType.InferFromData, EnhancementType.AddPathComment].includes(action);

            // --- Main execution block ---
            try {
                let targetFiles: string[] = [];
                // --- Identify Target Files ---
                if (action === EnhancementType.InferFromData) {
                    targetFiles.push(path.resolve(targetPath));
                } else if (stats.isDirectory()) {
                    targetFiles = await getTargetFiles(targetPath, prefix);
                    if (targetFiles.length === 0) {
                        console.log(`\n${logPrefix} No relevant files found matching criteria. Exiting.`);
                        return;
                    }
                    console.log(`${logPrefix} Found ${targetFiles.length} files to process.`);
                } else if (stats.isFile()) {
                    const filename = path.basename(targetPath);
                    if (EXCLUDE_FILENAMES.has(filename)) {
                        console.log(`${logPrefix} Target file ${filename} is excluded.`);
                        return;
                    }
                    targetFiles.push(path.resolve(targetPath));
                }

                // --- Process Based on Action Type ---
                if (isModificationAction && action === EnhancementType.AddComments) {
                    // Parallel modification logic...
                    const concurrencyLimit = 5;
                    const limit = pLimit(concurrencyLimit);
                    console.log(`\n${logPrefix} Starting PARALLEL modification action '${action}' on ${targetFiles.length} file(s)...`);
                    const fileProcessor = async (absoluteFilePath: string): Promise<FileProcessingResult> => { /* ... existing processor logic ... */
                        const relativeFilePath = path.relative(process.cwd(), absoluteFilePath).split(path.sep).join('/');
                        try {
                            const originalCode = readSingleFile(absoluteFilePath);
                            const result: GeminiEnhancementResult = await enhanceCodeWithGemini(action, originalCode);

                            if (result.type === 'code' && result.content !== null) {
                                if (originalCode.trim() !== result.content.trim()) {
                                    const updated = updateFileContent(absoluteFilePath, result.content);
                                    return { filePath: relativeFilePath, status: updated ? 'updated' : 'error', message: updated ? undefined : 'File write failed' };
                                } else {
                                    console.log(`    ${logPrefix} No changes needed for ${relativeFilePath}.`);
                                    return { filePath: relativeFilePath, status: 'unchanged' };
                                }
                            } else if (result.type === 'error') {
                                console.error(`    ${logPrefix} ❌ Gemini failed for ${relativeFilePath}: ${result.content}`);
                                return { filePath: relativeFilePath, status: 'error', message: `Gemini Error: ${result.content}` };
                            } else {
                                console.warn(`    ${logPrefix} ⚠️ Unexpected result type/content for ${relativeFilePath}.`);
                                return { filePath: relativeFilePath, status: 'error', message: `Unexpected result type/content: ${result.type}` };
                            }
                        } catch (fileProcessingError) {
                            console.error(`    ${logPrefix} ❌ Error during Gemini processing for ${relativeFilePath}: ${fileProcessingError instanceof Error ? fileProcessingError.message : fileProcessingError}`);
                            return { filePath: relativeFilePath, status: 'error', message: `File/API Processing Error: ${fileProcessingError instanceof Error ? fileProcessingError.message : "Unknown error"}` };
                        }
                    };
                    const tasks = targetFiles.map(filePath => limit(() => fileProcessor(filePath)));
                    const results: FileProcessingResult[] = await Promise.all(tasks);
                    // Summarize results...
                    let successCount = 0, unchangedCount = 0, errorCount = 0;
                    results.forEach(res => { /* ... tally results ... */
                        switch (res.status) {
                            case 'updated': successCount++; break;
                            case 'unchanged': unchangedCount++; break;
                            case 'error': errorCount++; break;
                        }
                    });
                    console.log("\n--- Parallel Modification Summary ---");
                    console.log(`  Action: ${action}, Files: ${targetFiles.length}, Updated: ${successCount}, Unchanged: ${unchangedCount}, Errors: ${errorCount}`);
                    console.log("-----------------------------------");
                    if (errorCount > 0) process.exitCode = 1;

                } else if (usesGeminiApi && !isModificationAction) {
                    // Non-modification Gemini logic...
                    let codeToProcess: string; /* ... get codeToProcess ... */
                    if (stats.isDirectory() || targetFiles.length > 1) {
                        const consolidationRoot = stats.isDirectory() ? targetPath : path.dirname(targetFiles[0]);
                        codeToProcess = await getConsolidatedSources(consolidationRoot, prefix);
                    } else if (targetFiles.length === 1) {
                        codeToProcess = readSingleFile(targetFiles[0]);
                    } else { /* error */ process.exit(1); }
                    if (codeToProcess.trim() === '') { /* warn and return */ return; }

                    console.log(`\n${logPrefix} Invoking Gemini service for action: ${action}...`);
                    const result: GeminiEnhancementResult = await enhanceCodeWithGemini(action, codeToProcess);
                    // Handle result (print or write file)...
                    if (result.type === 'text' && result.content !== null) {
                        if (action === EnhancementType.GenerateDocs) { /* write README.md */
                            const outputFileName = 'README.md';
                            const outputFilePath = path.resolve(process.cwd(), outputFileName);
                            console.log(`\n${logPrefix} Writing generated documentation to ${outputFileName}...`);
                            const success = writeOutputFile(outputFilePath, result.content);
                            if (!success) { /* error */ process.exitCode = 1; }
                            else { console.log(`\n${logPrefix} ✅ Documentation saved to: ${outputFileName}`); }
                        } else { /* print result */
                            console.log(`\n--- Gemini ${action} Result ---`);
                            console.log(result.content);
                            console.log(`--- End ${action} Result ---\n`);
                        }
                    } else if (result.type === 'error') { /* handle error */ process.exitCode = 1; }
                    else { /* handle unexpected type */ process.exitCode = 1; }

                } else if (isLocalProcessingAction) {
                    // Local processing logic...
                    if (action === EnhancementType.Consolidate) { /* consolidate logic */
                        const consolidationRoot = stats.isDirectory() ? targetPath : path.dirname(targetPath);
                        const consolidatedContent = await getConsolidatedSources(consolidationRoot, prefix);
                        const outputFileName = 'consolidated_output.txt';
                        const outputFilePath = path.resolve(process.cwd(), outputFileName);
                        const success = writeOutputFile(outputFilePath, consolidatedContent);
                        if (!success) process.exitCode = 1;
                        else console.log(`\n${logPrefix} ✅ Consolidated content saved to: ${outputFileName}`);
                    } else if (action === EnhancementType.InferFromData) { /* infer logic */
                        if (!interfaceName) { /* error */ process.exit(1); }
                        const dataFilePath = targetFiles[0];
                        const relativeDataFilePath = path.relative(process.cwd(), dataFilePath).split(path.sep).join('/');
                        try { /* read, parse, infer, print */
                            const fileContent = readSingleFile(dataFilePath);
                            let data: any;
                            try { data = JSON.parse(fileContent); } catch (e) { /* error */ process.exit(1); }
                            const inferredInterface = inferTypesFromData(interfaceName, data);
                            console.log(`\n--- Inferred Interface: ${interfaceName} ---\n${inferredInterface}\n--- End Interface ---`);
                        } catch (e) { /* error */ process.exit(1); }
                    } else if (action === EnhancementType.AddPathComment) { /* add path comment logic */
                        console.log(`\n${logPrefix} Starting SEQUENTIAL action '${action}' on ${targetFiles.length} file(s)...`);
                        let updatedCount = 0, unchangedCount = 0, skippedCount = 0, errorCount = 0;
                        const nonCommentableExtensions = new Set(['.json', '.env']);
                        const anyCommentRegex = /^\s*(\/\/.*|#.*)/;
                        for (const absoluteFilePath of targetFiles) { /* loop, skip, read, check, update */
                            const relativeFilePath = path.relative(process.cwd(), absoluteFilePath).split(path.sep).join('/');
                            const fileExtension = path.extname(absoluteFilePath).toLowerCase();
                            if (nonCommentableExtensions.has(fileExtension)) { skippedCount++; continue; }
                            try {
                                const pathComment = `// File: ${relativeFilePath}`;
                                const originalCode = readSingleFile(absoluteFilePath);
                                const lines = originalCode.split(/\r?\n/);
                                // Check if correct
                                let firstNonBlankLineIndex = lines.findIndex(line => line.trim() !== '');
                                if (firstNonBlankLineIndex === -1) firstNonBlankLineIndex = 0; // Handle empty file case
                                const firstNonBlankLine = lines[firstNonBlankLineIndex]?.trim() ?? '';

                                let alreadyCorrect = false;
                                if (firstNonBlankLineIndex === 0 && firstNonBlankLine === pathComment && (lines.length === 1 || (lines.length > 1 && lines[1].trim() === ''))) {
                                    alreadyCorrect = true;
                                }

                                if (alreadyCorrect) { unchangedCount++; continue; }
                                // Update
                                let firstCodeLineIndex = 0;
                                while (firstCodeLineIndex < lines.length && (lines[firstCodeLineIndex].trim() === '' || anyCommentRegex.test(lines[firstCodeLineIndex].trim()))) {
                                    firstCodeLineIndex++;
                                }
                                const codeContentLines = lines.slice(firstCodeLineIndex);
                                const codeContent = codeContentLines.length > 0 ? codeContentLines.join('\n') : '';
                                const newCode = `${pathComment}\n\n${codeContent}`;
                                const updated = updateFileContent(absoluteFilePath, newCode);
                                if (updated) updatedCount++; else errorCount++;
                            } catch (e) { errorCount++; }
                        }
                        // Summarize
                        console.log("\n--- Sequential Action Summary ---");
                        console.log(`  Action: ${action}, Files: ${targetFiles.length}, Updated: ${updatedCount}, Unchanged: ${unchangedCount}, Skipped: ${skippedCount}, Errors: ${errorCount}`);
                        console.log("---------------------------------");
                        if (errorCount > 0) process.exitCode = 1;
                    }
                } else {
                    console.error(`${logPrefix} Internal Error: Enhancement action "${action}" was not handled.`);
                    process.exit(1);
                }

            } catch (error) {
                console.error(`\n${logPrefix} ❌ An unexpected error occurred during enhancement action ${action}:`);
                if (error instanceof Error) console.error(`   Message: ${error.message}`);
                else console.error("   Unknown error object:", error);
                process.exit(1);
            }
            console.log(`\n${logPrefix} Execution finished for action: ${action}.`);
            break; // Exit the switch case
        }


        // Default case for the switch statement
        default: {
            console.error(`${logPrefix} ❌ Internal Error: Unhandled command type received: ${command}`);
            process.exit(1);
        }
    } // End switch statement

} // End runCommandLogic

// File: src/gemini/gemini.service.ts

import axios, { AxiosError, AxiosResponse } from 'axios';
import { GEMINI_API_ENDPOINT, GEMINI_API_KEY, GEMINI_MODEL_NAME } from '../config/app.config.js';
import { EnhancementType } from '../shared/enums/enhancement.type.js';
import { extractCodeBlock } from './utils/code.extractor.js';

// Log config when service is initialized (better than top-level in config file)
console.log(`[GeminiService] Initialized. Model: ${GEMINI_MODEL_NAME}, Endpoint: ${GEMINI_API_ENDPOINT}`);

/**
 * Represents the result of a Gemini enhancement operation.
 * NOTE: Keeping this interface here as it's tightly coupled to the service's return type.
 * If it needs to be shared more widely, move to shared/types.
 */
export interface GeminiEnhancementResult {
    /** The type of content returned: 'code', 'text', or 'error'. */
    type: 'code' | 'text' | 'error';
    /** The content of the result, which can be a string or null if an error occurred. */
    content: string | null;
}

/**
 * Generates a prompt for the Gemini API based on the enhancement type and code.
 *
 * @param {EnhancementType} enhancement - The type of enhancement to generate the prompt for.
 * @param {string} code - The code to be enhanced.
 * @returns {string} The generated prompt string.
 */
function generatePrompt(enhancement: EnhancementType, code: string): string {
    console.log(`[GeminiService] Generating prompt for enhancement type: ${enhancement}`);
    // ... (rest of generatePrompt code is identical to original)
    switch (enhancement) {
        case EnhancementType.AddComments:
            return `
Review the following TypeScript/JavaScript code. Add comprehensive TSDoc/JSDoc comments /** ... */ for all exported functions, classes, interfaces, types, and significant internal logic. Include @param, @returns, @throws tags where appropriate.
Also add concise inline comments // using // for complex or non-obvious implementation steps within functions or methods.
Ensure existing comments are preserved or improved if necessary.

**CRITICAL INSTRUCTION:** You MUST return the **ENTIRE, COMPLETE, ORIGINAL FILE CONTENT**, including all existing code and comments, with ONLY the new TSDoc/JSDoc and inline comments added or updated as requested. Do NOT omit any part of the original file.
**RESPONSE FORMAT:** Respond ONLY with the full, updated code block itself, enclosed in a single \`\`\`typescript ... \`\`\` or \`\`\`javascript ... \`\`\` block. Do not include ANY introductory text, closing remarks, or explanations outside the code block.

\`\`\`typescript
${code}
\`\`\`
`;
        case EnhancementType.Analyze: // Keep Analyze separate for potentially different focus later
            return `
Analyze the following code. Provide a high-level overview of its purpose, structure, and key components. Identify potential areas for improvement regarding clarity, efficiency, or adherence to best practices, but focus on analysis rather than direct suggestions.

\`\`\`typescript
${code}
\`\`\`
`;
        case EnhancementType.Explain:
            return `
Explain the following TypeScript/JavaScript code in simple terms. Describe its overall purpose, how the main parts work together, and what specific functions or classes are responsible for. Assume the reader has some programming knowledge but may not be familiar with this specific code.

\`\`\`typescript
${code}
\`\`\`
`;
        case EnhancementType.SuggestImprovements: // New
            return `
Act as a senior software engineer performing a code review on the following TypeScript/JavaScript code. Provide specific, actionable suggestions for improvement. Focus on:
1.  **Readability & Clarity:** Can variable names, function names, or structure be improved? Is the logic easy to follow?
2.  **Potential Bugs & Edge Cases:** Are there any obvious logical errors, potential null/undefined issues, or unhandled edge cases?
3.  **Best Practices:** Does the code follow common language idioms and best practices (e.g., error handling, immutability, proper use of async/await)?
4.  **Performance:** Are there any obvious performance bottlenecks or areas where efficiency could be significantly improved? (Avoid premature optimization).
5.  **Maintainability:** How easy would it be to modify or extend this code later? Suggest ways to improve modularity or reduce coupling if applicable.

**RESPONSE FORMAT:** Present your suggestions clearly, perhaps using bullet points or numbered lists, referencing specific lines or sections of the code where possible. Be constructive and explain the reasoning behind each suggestion. Do NOT rewrite the code yourself. Respond only with the suggestions.

\`\`\`typescript
${code}
\`\`\`
`;
        case EnhancementType.GenerateDocs: // New
            return `
Analyze the following TypeScript/JavaScript code and generate documentation in Markdown format suitable for a README file section or a separate documentation file.

The documentation should include:
1.  **Overview:** A brief description of the code's overall purpose and functionality.
2.  **Key Components:** Descriptions of major functions, classes, or modules, including their responsibilities.
3.  **Usage Examples (if applicable):** Show how to use the primary functions or classes with simple examples.
4.  **Inputs/Outputs (if applicable):** Describe important function parameters and return values.

**RESPONSE FORMAT:** Respond ONLY with the generated Markdown content. Do not include any introductory text, closing remarks, or explanations outside the Markdown. Start directly with the Markdown content (e.g., starting with a heading like '## Module Documentation').

\`\`\`typescript
${code}
\`\`\`
`;
        // Note: InferFromData does not use Gemini, so no prompt needed here.
        // Note: AddPathComment and Consolidate do not use Gemini.

        default:
            // Should not happen if using enum correctly, but good practice
            console.warn(`[GeminiService] Unknown enhancement type for prompt generation: ${enhancement}. Using generic prompt.`);
            // Returns a generic prompt as a fallback
            return `Review and provide feedback on the following code:\n\n\`\`\`typescript\n${code}\n\`\`\``;
    }


/**
 * Calls the Gemini API with a given prompt.
 *
 * @param {string} promptText - The prompt text to send to the Gemini API.
 * @returns {Promise<string | null>} A promise that resolves with the response text, or null if an error occurred.
 */
async function callGeminiApi(promptText: string): Promise<string | null> {
    console.log(`[GeminiService] Sending request to Gemini API (${promptText.length} chars)...`);

    const requestData = {
        contents: [{ parts: [{ text: promptText }] }],
        // Optional: Configure generation parameters
        // generationConfig: { ... },
        // Optional: Safety Settings
        // safetySettings: [ ... ]
    };

    const config = {
        headers: { 'Content-Type': 'application/json' },
        params: { key: GEMINI_API_KEY },
        timeout: 120000
    };

    try {
        // Attempt to make the POST request to the Gemini API
        const response: AxiosResponse = await axios.post(GEMINI_API_ENDPOINT, requestData, config);

        // Robustly check for response structure and potential blocks
        const candidate = response.data?.candidates?.[0];

        if (candidate?.finishReason && candidate.finishReason !== "STOP") {
            console.warn(`[GeminiService] Warning: Response generation finished due to reason: ${candidate.finishReason}.`);
            if (candidate.finishReason === "SAFETY") {
                console.error("[GeminiService] ❌ Error: Gemini blocked the response due to safety settings.");
                if (candidate.safetyRatings) {
                    console.error("[GeminiService] Safety Ratings:", JSON.stringify(candidate.safetyRatings, null, 2));
                }
                return null;
            }

        const responseText = candidate?.content?.parts?.[0]?.text;

        if (responseText) {
            console.log(`[GeminiService] Received response (${responseText.trim().length} chars).`);
            return responseText.trim();
        } else {
            console.warn("[GeminiService] Warning: Received response, but no text content found.");
            console.log("[GeminiService] Full Response Data:", JSON.stringify(response.data, null, 2));
            return null;
        }
    } catch (error) {
        console.error("[GeminiService] ❌ Error calling Gemini API:");
        // Cast the error to AxiosError to access response data
        const axiosError = error as AxiosError;
        if (axiosError.response) {
            console.error(`  Status: ${axiosError.response.status}`);
            console.error(`  Data: ${JSON.stringify(axiosError.response.data, null, 2)}`);
            const geminiError = (axiosError.response.data as any)?.error;
            if (geminiError) {
                console.error(`  Gemini Error Code: ${geminiError.code}`);
                console.error(`  Gemini Error Message: ${geminiError.message}`);
                console.error(`  Gemini Error Status: ${geminiError.status}`);
            }
        } else if (axiosError.request) {
            console.error("  Request Error: No response received.", axiosError.code);
        } else {
            console.error('  Setup Error Message:', axiosError.message);
        }
        return null;
    }


/**
 * Enhances the given code with Gemini based on the specified enhancement type.
 *
 * @param {EnhancementType} enhancementType - The type of enhancement to apply.
 * @param {string} code - The code to be enhanced.
 * @returns {Promise<GeminiEnhancementResult>} A promise that resolves with the enhancement result.
 */
export async function enhanceCodeWithGemini(
    enhancementType: EnhancementType,
    code: string
): Promise<GeminiEnhancementResult> {

    // Actions expected to return code
    const expectsCode = [
        EnhancementType.AddComments,
    ].includes(enhancementType);

    // Actions expected to return text
    const expectsText = [
        EnhancementType.Analyze,
        EnhancementType.Explain,
        EnhancementType.SuggestImprovements,
        EnhancementType.GenerateDocs,
    ].includes(enhancementType);

    // Generate the prompt based on the enhancement type and code
    const prompt = generatePrompt(enhancementType, code);
    if (!prompt) {
        return { type: 'error', content: `Failed to generate prompt for action: ${enhancementType}` };
    }

    // Call Gemini API with the generated prompt
    const rawResponse = await callGeminiApi(prompt);

    if (rawResponse === null) {
        return { type: 'error', content: 'Failed to get a valid response from Gemini API.' };
    }

    if (expectsCode) {
        console.log(`[GeminiService] Processing response for ${enhancementType} (expects code)...`);
        // Extract code block from the raw response
        const extractedCode = extractCodeBlock(rawResponse); // Use local utility
        if (extractedCode) {
            console.log("[GeminiService] Code block extracted successfully.");
            return { type: 'code', content: extractedCode };
        } else {
            console.warn(`[GeminiService] ${enhancementType} requested, but couldn't extract a fenced code block.`);
            console.log("--- Full Raw Response (for debugging code extraction) ---");
            console.log(rawResponse);
            console.log("--- End Full Raw Response ---");
            return { type: 'error', content: `Failed to extract valid code block from Gemini response for ${enhancementType}. Raw response logged.` };
        }
    } else if (expectsText) {
        console.log(`[GeminiService] Processing response for ${enhancementType} (expects text)...`);
        // Return the raw response as text
        return { type: 'text', content: rawResponse };
    } else {
        console.error(`[GeminiService] Internal Error: Unhandled enhancement type: ${enhancementType}`);
        return { type: 'error', content: `Unhandled enhancement type: ${enhancementType}` };
    }

// File: src/index.ts

import { runCli } from './gemini/cli/gemini.cli.js';

/**
 * Entry point for the Gemini CLI application.
 * Parses command-line arguments and executes the corresponding Gemini command.
 *
 * @param argv - An array of strings representing the command-line arguments passed to the application.
 *               Typically, this is `process.argv`.
 * @returns void - The function does not return a value directly but initiates the Gemini CLI process.
 */
runCli(process.argv); // Pass command line arguments

// File: src/shared/constants/filesystem.constants.ts

/**
 * Set of file extensions to include during inspection.
 * This set is used to filter files during directory traversal, ensuring that only files with these extensions are processed.
 */
export const INCLUDE_EXTENSIONS: Set<string> = new Set([
    ".ts",
    ".js",
    ".json",
    ".env",
]);

/**
 * Set of directory or file name patterns to exclude during inspection.
 * During directory traversal, any directory or file name matching these patterns will be skipped.
 * This helps to avoid processing unnecessary or irrelevant files.
 */
export const EXCLUDE_PATTERNS: Set<string> = new Set([
    "node_modules",
    "dist",
    "build",
    ".git",
    "coverage",
]);

/**
 * Set of specific filenames to exclude during inspection.
 * This set provides a way to exclude specific files from the inspection process, regardless of their location.
 * This can be useful for excluding configuration files or other files that should not be processed.
 */
export const EXCLUDE_FILENAMES: Set<string> = new Set([
    "package-lock.json",
    "consolidated_sources.ts", // Exclude potential consolidation output if run in src
    "consolidated_output.txt", // Exclude consolidation output
    "code.extractor.ts", // Exclude utility if present
    "README.md", // Exclude generated docs
    "docs.md", // Exclude previously generated docs just in case
]);

// File: src/shared/enums/enhancement.type.ts

// src/shared/enums/enhancement.type.ts

/**
 * Enum representing the different types of code enhancement or utility actions
 * that can be performed by the CLI tool.
 */
export enum EnhancementType {
	// --- AI-Driven Enhancements ---
	/** Add TSDoc/JSDoc and inline comments to the code. */
	AddComments = 'AddComments',
	/** Provide a high-level analysis of code structure and quality. */
	Analyze = 'Analyze',
	/** Explain what the code does in simple terms. */
	Explain = 'Explain',
	/** Suggest specific, actionable improvements for the code. */
	SuggestImprovements = 'SuggestImprovements',
	/** Generate Markdown documentation (e.g., for README). */
	GenerateDocs = 'GenerateDocs',

	// --- Local Code/File Manipulations ---
	/** Add a '// File: <relativePath>' comment header to files (Local Action). */
	AddPathComment = 'AddPathComment',
	/** Consolidate multiple source files into a single output file (Local Action). */
	Consolidate = 'Consolidate',
	/** Infer TypeScript interface from a JSON data file (Local Action). */
	InferFromData = 'InferFromData',
	/** Generate a Markdown file representing the project directory structure (Local Action). */
	GenerateStructureDoc = 'GenerateStructureDoc', // <<< Added Here

	// Add more types here in the future (e.g., GenerateTests, Refactor)
}

/**
 * Type guard function to check if a given string is a valid EnhancementType value.
 * Useful for validating command inputs or data.
 *
 * @param value The string value to check.
 * @returns True if the value is a valid member of the EnhancementType enum, false otherwise.
 */
export function isValidEnhancementType(value: string): value is EnhancementType {
	return Object.values(EnhancementType).includes(value as EnhancementType);
}

// File: src/shared/helpers/filesystem.helper.ts

import { promises as fs } from "fs";
import * as path from "path";

const logPrefix = "[FileSystemHelper]";

/**
 * Recursively traverse a directory and return all file paths, respecting exclusion patterns.
 * @param dir The directory to traverse.
 * @param excludePatterns A set of directory or file names to exclude from the traversal.
 * @param excludeFilenames A set of specific filenames to exclude from the traversal.
 * @returns A promise that resolves to an array of file paths.
 * @throws {Error} If there is an error reading a directory or statting a file. Errors are logged to the console.
 */
export async function getAllFiles(
    dir: string,
    excludePatterns: Set<string>,
    excludeFilenames: Set<string>
): Promise<string[]> {
    let results: string[] = [];
    try {
        const list = await fs.readdir(dir); // Read the contents of the directory
        for (const file of list) {
            const filePath = path.join(dir, file); // Create the full file path

            if (excludePatterns.has(file) || excludeFilenames.has(file)) {
                continue; // Skip files that match the exclude patterns or filenames
            }

            try {
                const stat = await fs.stat(filePath); // Get file/directory stats
                if (stat && stat.isDirectory()) {
                    results = results.concat(await getAllFiles(filePath, excludePatterns, excludeFilenames)); // Recursively call getAllFiles for directories
                } else {
                    results.push(filePath); // Add file path to results
                }
            } catch (statError) {
                console.warn(`${logPrefix} Warning: Could not stat file/dir: ${filePath}. Skipping. Error: ${statError instanceof Error ? statError.message : statError}`);
            }
    } catch (readdirError) {
        console.error(`${logPrefix} Error reading directory: ${dir}. Error: ${readdirError instanceof Error ? readdirError.message : readdirError}`);
    }
    return results;
}

/**
 * Removes leading blank lines and specific comment markers, filters duplicate consecutive lines.
 * @param lines An array of strings representing the lines of a file.
 * @param friendlyPath A file path to use when filtering comment markers.
 * @returns An array of strings representing the filtered lines.
 */
export function filterLines(lines: string[], friendlyPath: string): string[] {
    let startIndex = 0;
    const pathCommentRegex = /^\s*\/\/\s*File:\s*(.+)\s*$/;

    // Remove leading blank lines and path comments.
    while (startIndex < lines.length) {
        const firstLine = lines[startIndex].trim();
        if (firstLine === "") {
            startIndex++;
        } else if (pathCommentRegex.test(firstLine) && firstLine.includes(friendlyPath)) {
            startIndex++;
        } else {
            break;
        }

    const relevantLines = lines.slice(startIndex);
    const filteredLines: string[] = [];
    let prevLineTrimmed: string | null = null;

    // Filter duplicate consecutive lines.
    for (const line of relevantLines) {
        const currentLineTrimmed = line.trim();
        if (currentLineTrimmed !== "" && currentLineTrimmed === prevLineTrimmed) {
            continue; // Skip if the current line is the same as the previous line
        }
        filteredLines.push(line);
        prevLineTrimmed = currentLineTrimmed;
    }
    return filteredLines;
}

// File: src/shared/helpers/type-inference.helper.ts

/**
 * Recursively determines the TypeScript type of a given value.
 * Handles primitive types, arrays, objects, functions, Date instances, and potential date strings.
 *
 * @param {any} value - The value whose type is to be determined.
 * @returns {string} - A string representing the TypeScript type of the given value.
 * @warning The detection of date strings using regex is a heuristic and may misclassify
 *          strings that coincidentally match the ISO 8601 format.
 * @warning This function does not handle circular references in objects. Processing data
 *          with circular references will likely result in a 'Maximum call stack size exceeded' error.
 */
function getType(value: any): string {
    if (value === null) {
        return "null";
    } else if (value === undefined) {
        // Represent undefined explicitly, although less common in JSON
        return "undefined";
    } else if (typeof value === "function") {
        // Functions aren't typical in data structures like JSON, but handle for completeness
        return "Function";
    } else if (Array.isArray(value)) {
        if (value.length === 0) {
            return "Array<any>"; // Or perhaps "unknown[]" or "any[]" based on preference
        }
        // Infer type from elements, handling potentially mixed types
        const uniqueTypes = new Set(value.map((item) => getType(item)));
        // Sort for consistent output if multiple types are present
        return `Array<${Array.from(uniqueTypes).sort().join(" | ")}>`;
    } else if (value instanceof Date) {
        return "Date";
    } else if (typeof value === "string") {
        // Basic check for ISO 8601 Date string format (heuristic)
        // Note: This is a simple heuristic and might misclassify strings that coincidentally match
        if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{1,3})?Z$/.test(value)) {
            return "Date"; // Suggest Date if it looks like an ISO string
        }
        return "string";
    } else if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        // Ensure it's a plain object, not null or an array
        // Potential stack overflow here if obj has circular references
        return getInterface(value);
    }
    // Fallback for primitive types like number, boolean, bigint, symbol
    return typeof value;
}

/**
 * Constructs a TypeScript interface representation (as a string) for a given object.
 * This function recursively calls getType to handle nested structures.
 *
 * @param {object} obj - The object to convert into a TypeScript interface string.
 * @returns {string} - A formatted string representing the TypeScript type interface of the object.
 * @warning This function does not handle circular references. If 'obj' contains circular
 *          references, this may lead to infinite recursion and stack overflow.
 */
function getInterface(obj: object): string {
    const properties = Object.entries(obj).map(
        // Recursively get type for each property value
        ([key, val]) => `  ${key}: ${getType(val)};` // Indent properties // Recursive call
    );
    // Sort properties alphabetically for consistent output
    properties.sort();
    // Format as an inline object type definition
    return `{\n${properties.join("\n")}\n}`;
}

/**
 * Infers TypeScript interface definitions from sample data (e.g., parsed JSON).
 * Handles single objects or arrays of objects, merging properties and types found across all items.
 *
 * @param {string} interfaceName - The desired name for the root TypeScript interface.
 * @param {any} data - The sample data (object or array of objects) to analyze.
 *                     It's assumed this data is JSON-like (no functions, Maps, Sets, etc. handled specifically).
 * @returns {string} - A formatted string representing the generated TypeScript interface.
 * @throws {Error} If the input data is not a single object or an array of objects.
 * @note This service is primarily designed for JSON data. Support for other formats like YAML
 *       would require adding specific parsers.
 * @warning Does not handle circular references within the data structure.
 * @warning Date string detection is based on a simple regex heuristic.
 */
export function inferTypesFromData(interfaceName: string, data: any): string {
    // Validate input data structure
    const isObject = typeof data === 'object' && data !== null && !Array.isArray(data);
    const isArrayOfObjects = Array.isArray(data) && data.every(item => typeof item === 'object' && item !== null);

    if (!isObject && !isArrayOfObjects) {
        throw new Error("Invalid input data: Must be a single object or an array of objects.");
    }
    if (Array.isArray(data) && data.length === 0) {
        console.warn("[Inference] Input data is an empty array. Generating an empty interface.");
        return `interface ${interfaceName} {}\n`;
    }


    // Normalize data to always be an array for consistent processing
    const normalizedData = Array.isArray(data) ? data : [data];
    // Use a Map to store types for each key, preserving insertion order for keys if needed later,
    // but sorting keys alphabetically before output for consistency.
    const typeDefinitions: Map<string, Set<string>> = new Map();

    // Iterate through each item in the normalized data array
    normalizedData.forEach((item) => {
        // Ensure item is a valid object before processing its entries
        if (typeof item === 'object' && item !== null) {
            // Iterate through each key-value pair in the object
            Object.entries(item).forEach(([key, value]) => {
                const valueType = getType(value); // Infer type of the value
                // Initialize the Set for this key if it doesn't exist yet
                if (!typeDefinitions.has(key)) {
                    typeDefinitions.set(key, new Set());
                }
                // Add the inferred type to the Set for this key
                typeDefinitions.get(key)?.add(valueType);
            });
        } else {
            console.warn("[Inference] Skipping non-object item in array:", item);
        }
    });

    // Construct the interface string lines
    const lines: string[] = [`interface ${interfaceName} {`];
    // Get keys and sort them alphabetically for consistent interface property order
    const sortedKeys = Array.from(typeDefinitions.keys()).sort();

    // Add each property definition to the interface lines
    sortedKeys.forEach((key) => {
        const typesSet = typeDefinitions.get(key);
        if (typesSet) {
            // Get unique types, sort them, and join with " | " for union types
            const types = Array.from(typesSet).sort().join(" | ");
            lines.push(`  ${key}: ${types};`); // Add indented property line
        }
    });

    lines.push("}"); // Closing brace for the interface
    return lines.join("\n"); // Join lines into a single string
}

// File: src/shared/types/app.type.ts

// src/shared/types/app.type.ts

import { EnhancementType } from '../enums/enhancement.type.js';

/**
 * Represents the unified command-line arguments passed to the application,
 * including arguments specific to different commands.
 */
export interface CliArguments {
    /** The specific enhancement or utility action requested. */
    command: EnhancementType;

    /** The target file or directory path (used by most commands, default for GenerateStructureDoc). */
    targetPath: string;

    /** Optional filename prefix filter (used by file-processing commands). */
    prefix?: string;

    /** Optional name for the generated interface (used by InferFromData). */
    interfaceName?: string;

    /** Path for the output Markdown file (used by GenerateStructureDoc, has default). */
    output?: string; // Changed to optional as it only applies to one command

    /** Flag to include standard descriptions (used by GenerateStructureDoc, has default). */
    descriptions?: boolean; // Changed to optional

    /** Optional maximum directory depth (used by GenerateStructureDoc). */
    depth?: number;

    /** Optional comma-separated list of additional exclude patterns (used by GenerateStructureDoc, has default). */
    exclude?: string; // Changed to optional

    // --- Standard yargs properties ---
    [key: string]: unknown; // Allow other yargs properties
    _: (string | number)[]; // Positional args not mapped to specific options
    $0: string;             // The script name or path as executed
}


/**
 * Represents the result of processing a single file,
 * often used in summarizing batch operations.
 */
export interface FileProcessingResult {
    /** The relative path of the processed file. */
    filePath: string;
    /** The outcome of the processing for this file. */
    status: 'updated' | 'unchanged' | 'error' | 'processed';
    /** Optional message, typically used for errors or warnings. */
    message?: string;
}

// File: src/shared/utils/file-io.utils.ts

import * as fs from 'fs';
import * as path from 'path';

const logPrefix = "[FileIO]";

/**
 * Reads the content of a single file synchronously.
 * @param {string} filePath - The path to the file to read.
 * @returns {string} The content of the file as a string.
 * @throws {Error} If the file does not exist or cannot be read.
 */
export function readSingleFile(filePath: string): string {
    const relativeFilePath = path.relative(process.cwd(), filePath).split(path.sep).join('/');
    try {
        const stats = fs.statSync(filePath);
        if (!stats.isFile()) {
            throw new Error(`Target path is not a file: ${relativeFilePath}`);
        }
        const content = fs.readFileSync(filePath, 'utf8'); // Read the file content in UTF-8 encoding.
        // console.log(`${logPrefix} Read ${content.length} chars from ${relativeFilePath}.`); // Keep logging minimal
        return content;
    } catch (readError) {
        console.error(`${logPrefix} ❌ Error reading file ${relativeFilePath}: ${readError instanceof Error ? readError.message : readError}`);
        throw readError;
    }

/**
 * Updates the content of a file synchronously. Creates parent directory if needed.
 * @param {string} filePath - The path to the file to update.
 * @param {string} newContent - The new content to write to the file.
 * @returns {boolean} True if the file was successfully updated, false otherwise.
 */
export function updateFileContent(filePath: string, newContent: string): boolean {
    const relativeFilePath = path.relative(process.cwd(), filePath).split(path.sep).join('/');
    console.warn(`${logPrefix} ⚠️ Attempting to overwrite ${relativeFilePath}...`);
    try {
        const outputDir = path.dirname(filePath);
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true }); // Create the directory recursively if it doesn't exist.
            console.log(`${logPrefix} Created directory: ${path.relative(process.cwd(), outputDir)}`);
        }
        fs.writeFileSync(filePath, newContent, 'utf8'); // Write the new content to the file in UTF-8 encoding.
        console.log(`${logPrefix} ✅ Successfully updated ${relativeFilePath}.`);
        return true;
    } catch (writeError) {
        console.error(`${logPrefix} ❌ Error writing file ${relativeFilePath}: ${writeError instanceof Error ? writeError.message : writeError}`);
        return false;
    }

/**
 * Writes content to a specified output file. Creates parent directory if needed.
 * @param {string} outputFilePath - The path to the output file.
 * @param {string} content - The content to write to the output file.
 * @returns {boolean} True if the file was successfully written, false otherwise.
 */
export function writeOutputFile(outputFilePath: string, content: string): boolean {
    const relativeOutputPath = path.relative(process.cwd(), outputFilePath).split(path.sep).join('/');
    console.log(`${logPrefix} Writing output to ${relativeOutputPath}...`);
    try {
        const outputDir = path.dirname(outputFilePath);
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true }); // Create the directory recursively if it doesn't exist.
            console.log(`${logPrefix} Created directory: ${path.relative(process.cwd(), outputDir)}`);
        }
        fs.writeFileSync(outputFilePath, content, 'utf8'); // Write the content to the output file in UTF-8 encoding.
        console.log(`${logPrefix} ✅ Successfully wrote ${content.length} characters to ${relativeOutputPath}.`);
        return true;
    } catch (writeError) {
        console.error(`${logPrefix} ❌ Error writing output file ${relativeOutputPath}: ${writeError instanceof Error ? writeError.message : writeError}`);
        return false;
    }

// File: src/shared/utils/filesystem.utils.ts

import { promises as fs } from "fs";
import * as path from "path";
import { INCLUDE_EXTENSIONS, EXCLUDE_PATTERNS, EXCLUDE_FILENAMES } from '../constants/filesystem.constants.js'; // Correct path
import { filterLines, getAllFiles } from "../helpers/filesystem.helper.js"; // Correct path

const logPrefix = "[FileSystemUtil]"; // Renamed prefix for clarity

/**
 * Finds all relevant source files within a directory based on config.
 * @param {string} rootDir - The root directory to search in.
 * @param {string} [filePrefix=""] - An optional file prefix to filter files by.
 * @returns {Promise<string[]>} A promise that resolves to an array of file paths that match the criteria.
 * @throws {Error} If the target directory does not exist or is not accessible.
 */
export async function getTargetFiles(rootDir: string, filePrefix: string = ""): Promise<string[]> {
    console.log(`${logPrefix} Searching for target files in root: ${rootDir}${filePrefix ? `, prefix: '${filePrefix}'` : ''}`);
    let absRoot: string;
    try {
        absRoot = path.resolve(rootDir); // Resolve the root directory to an absolute path.
        const stats = await fs.stat(absRoot);
        if (!stats.isDirectory()) {
            throw new Error(`Target path is not a directory: ${rootDir}`);
        }
        await fs.access(absRoot); // Verify we have access to the directory.
    } catch (error) {
        console.error(`${logPrefix} Error accessing target directory: ${rootDir}`);
        throw new Error(`Failed: Cannot access target directory '${rootDir}'. ${error instanceof Error ? error.message : ''}`);
    }

    const allFiles = await getAllFiles(absRoot, EXCLUDE_PATTERNS, EXCLUDE_FILENAMES); // Use helper
    console.log(`${logPrefix} Found ${allFiles.length} potential files in directory tree.`);

    const targetFiles = allFiles.filter(filePath => {
        const fileName = path.basename(filePath); // Extract the filename from the full path.
        const passesPrefix = !filePrefix || fileName.startsWith(filePrefix); // Check if the filename starts with the given prefix.
        const passesExtension = INCLUDE_EXTENSIONS.has(path.extname(fileName).toLowerCase()); // Check if the file extension is in the allowed list.
        return passesPrefix && passesExtension;
    });

    console.log(`${logPrefix} Found ${targetFiles.length} target files matching criteria.`);
    return targetFiles;
}

/**
 * Consolidates source files from a directory into a single string.
 * @param {string} rootDir - The root directory to consolidate files from.
 * @param {string} [filePrefix=""] - An optional file prefix to filter files by.
 * @returns {Promise<string>} A promise that resolves to a single string containing the concatenated content of all target files.
 * @throws {Error} If the root directory does not exist or is not accessible.
 */
export async function getConsolidatedSources(rootDir: string, filePrefix: string = ""): Promise<string> {
    console.log(`${logPrefix} Starting consolidation for root: ${rootDir}${filePrefix ? `, prefix: '${filePrefix}'` : ''}`);

    const seenFiles: Set<string> = new Set(); // Keep track of files already processed to avoid duplicates.
    const now = new Date().toISOString().slice(0, 19).replace("T", " "); // Get current timestamp for the header.
    let absRoot: string;
    try {
        absRoot = path.resolve(rootDir); // Resolve the root directory to an absolute path.
        await fs.access(absRoot); // Verify we have access to the directory.
    } catch (error) {
        console.error(`${logPrefix} Error accessing root directory: ${rootDir}`);
        throw new Error(`Failed: Cannot access root directory '${rootDir}'. ${error instanceof Error ? error.message : ''}`);
    }

    const header = `// Consolidated sources from: ${absRoot}\n` +
        `// Consolidation timestamp: ${now}\n` +
        `// Tool Name: gemini-poc (inspector module)\n` +
        `// Root Directory: ${absRoot}\n` +
        `// Include Extensions: ${[...INCLUDE_EXTENSIONS].sort().join(", ")}\n` +
        `// Exclude Patterns/Files: ${[...EXCLUDE_PATTERNS, ...EXCLUDE_FILENAMES].sort().join(", ")}\n\n`;

    let outputContent = header;
    const allFiles = await getAllFiles(absRoot, EXCLUDE_PATTERNS, EXCLUDE_FILENAMES); // Use helper
    console.log(`${logPrefix} Found ${allFiles.length} potential files.`);

    for (const filePath of allFiles) {
        const fileName = path.basename(filePath); // Extract the filename from the full path.
        if (filePrefix && !fileName.startsWith(filePrefix)) continue;
        if (!INCLUDE_EXTENSIONS.has(path.extname(fileName).toLowerCase())) continue;

        let canonicalPath: string;
        try {
            canonicalPath = await fs.realpath(filePath); // Get the absolute, canonical path to handle symlinks correctly.
        } catch (realpathError) {
            console.warn(`${logPrefix} Warning: Could not get real path for ${filePath}. Skipping. Error: ${realpathError instanceof Error ? realpathError.message : realpathError}`);
            continue;
        }

        if (seenFiles.has(canonicalPath)) continue; // Skip if already processed.
        seenFiles.add(canonicalPath);

        const relativePath = path.relative(absRoot, canonicalPath); // Get the relative path from the root directory.
        const friendlyPath = relativePath.split(path.sep).join("/"); // Convert the path to a platform-independent format.
        const commentLine = `// File: ${friendlyPath}`;
        console.log(`  ${logPrefix} Processing: ${friendlyPath}`);

        let fileData: string;
        let lines: string[];
        try {
            fileData = await fs.readFile(canonicalPath, "utf-8"); // Read the file content.
            lines = fileData.split(/\r?\n/); // Split the file content into lines.
        } catch (error) {
            console.warn(`  ${logPrefix} Warning: Error reading ${friendlyPath}. Skipping. Error: ${error instanceof Error ? error.message : error}`);
            continue;
        }

        const filtered = filterLines(lines, friendlyPath); // Filter the lines based on exclude patterns.

        if (filtered.length > 0 || fileData.trim() !== '') {
            outputContent += `${commentLine}\n\n`;
            outputContent += filtered.join("\n") + "\n\n";
        } else {
            console.log(`  ${logPrefix} Skipping empty or fully filtered file: ${friendlyPath}`);
        }

    console.log(`${logPrefix} Consolidation complete. Total length: ${outputContent.length} characters.`);
    return outputContent;
}

// File: tsconfig.json

{
  "compilerOptions": {
    "module": "NodeNext", // Specify ESM output compatible with Node.js
    "moduleResolution": "NodeNext", // Use Node's modern module resolution
    "target": "ES2020", // Or newer (ES2020 supports top-level await used in main)
    "outDir": "./dist", // Your existing output directory
    "rootDir": "./src", // Your existing source directory
    "esModuleInterop": true, // Usually helpful for CJS/ESM interop
    "forceConsistentCasingInFileNames": true,
    "strict": true, // Recommended
    "skipLibCheck": true // Often needed for smoother builds
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.spec.ts"]
}


