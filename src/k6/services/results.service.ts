// File: src/k6/services/results.service.ts

import * as fs from "fs/promises";
import papaparse from "papaparse";

const logPrefix = "[K6ResultsService]";

/**
 * Interface representing a row from the raw k6 CSV metrics output.
 * We only define the fields we actively use for processing.
 */
interface RawK6Metric {
  metric_name: string;
  group: string;
  check?: string;
  metric_value?: number;
}

/**
 * Interface for the structured data in our final, powerful summary report.
 */
interface TestSummary {
  testName: string;
  result: "PASS" | "FAIL";
  totalChecks: number;
  passedChecks: number;
  failedChecks: number;
  avgDurationMs: number;
}

/**
 * A simple helper function to calculate the average of an array of numbers.
 * @param arr An array of numbers.
 * @returns The average of the numbers in the array.
 */
const average = (arr: number[]) => arr.reduce((p, c) => p + c, 0) / arr.length;

/**
 * Processes a raw k6 CSV output file and generates a human-readable summary CSV.
 * This is the core function that transforms the detailed k6 metrics into an actionable summary.
 *
 * @param rawCsvPath The path to the input raw CSV file generated by k6 (`--out csv=...`).
 * @param summaryCsvPath The path where the new summary CSV file will be written.
 * @throws An error if the raw k6 CSV file cannot be read or parsed.
 */
export async function generateSummaryCsv(
  rawCsvPath: string,
  summaryCsvPath: string
): Promise<void> {
  console.log(`${logPrefix} Processing raw k6 output from: ${rawCsvPath}`);

  const fileContent = await fs.readFile(rawCsvPath, "utf-8");
  const parseResult = papaparse.parse<RawK6Metric>(fileContent, {
    header: true,
    skipEmptyLines: true,
    dynamicTyping: true, // Automatically convert numbers
  });

  if (parseResult.errors.length) {
    throw new Error(
      `Failed to parse raw k6 CSV: ${parseResult.errors[0].message}`
    );
  }

  const metrics = parseResult.data;
  const testGroups = new Map<
    string,
    { checks: RawK6Metric[]; durations: number[] }
  >();

  // Step 1: Aggregate all relevant metrics by their group name (which corresponds to our testName).
  for (const metric of metrics) {
    // We only care about metrics within a specific group, prefixed with '::' by our script.
    if (!metric.group || !metric.group.startsWith("::")) {
      continue;
    }

    const groupName = metric.group.substring(2); // Remove the '::' prefix to get the clean test name.

    if (!testGroups.has(groupName)) {
      testGroups.set(groupName, { checks: [], durations: [] });
    }

    const groupData = testGroups.get(groupName)!;

    // Collect all 'checks' metrics for this group.
    if (metric.metric_name === "checks" && metric.check) {
      groupData.checks.push(metric);
    }
    // Collect all request duration metrics for this group to calculate an average later.
    if (
      metric.metric_name === "http_req_duration" &&
      typeof metric.metric_value === "number"
    ) {
      groupData.durations.push(metric.metric_value);
    }
  }

  // Step 2: Calculate the final summary statistics for each aggregated group.
  const summaries: TestSummary[] = [];
  for (const [testName, data] of testGroups.entries()) {
    const totalChecks = data.checks.length;
    // A passed check has a metric_value of 1.
    const passedChecks = data.checks.filter((c) => c.metric_value === 1).length;

    summaries.push({
      testName: testName,
      // A test PASSES if it has at least one check and all of its checks passed.
      result: totalChecks > 0 && passedChecks === totalChecks ? "PASS" : "FAIL",
      totalChecks,
      passedChecks,
      failedChecks: totalChecks - passedChecks,
      avgDurationMs: data.durations.length > 0 ? average(data.durations) : 0,
    });
  }

  if (summaries.length === 0) {
    console.warn(
      `${logPrefix} No test groups found in raw data. Summary CSV will not be generated.`
    );
    return;
  }

  // Step 3: Convert the summary data back to CSV format and write it to the specified file.
  const summaryCsvContent = papaparse.unparse(summaries);
  await fs.writeFile(summaryCsvPath, summaryCsvContent, "utf-8");
  console.log(
    `${logPrefix} âœ… Powerful summary report generated at: ${summaryCsvPath}`
  );
}
