// Consolidated sources from: /home/devvi/opt/personal-projects/gemini-poc
// Consolidation timestamp: 2025-04-14 08:10:01
// Tool Name: gemini-poc (inspector module)
// Root Directory: /home/devvi/opt/personal-projects/gemini-poc
// Include Extensions: .env, .js, .json, .ts
// Exclude Patterns/Files: .git, README.md, build, code.extractor.ts, consolidated_output.txt, consolidated_sources.ts, coverage, dist, docs.md, node_modules, package-lock.json

// File: package.json

{
  "name": "gemini-poc",
  "version": "1.0.0",
  "description": "Proof of concept using Google Gemini API for code tasks",
  "type": "module",
  "main": "dist/app.js",
  "scripts": {
    "clean": "rimraf ./dist",
    "build": "npm run clean && tsc",
    "start": "node dist/index.js",
    "dev": "tsx src/index.ts",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "gemini",
    "ai",
    "typescript",
    "poc"
  ],
  "author": "Your Name",
  "license": "ISC",
  "dependencies": {
    "axios": "^1.7.2",
    "dotenv": "^16.4.5",
    "p-limit": "^5.0.0",
    "yargs": "^17.7.2"
  },
  "devDependencies": {
    "@types/axios": "^0.14.0",
    "@types/node": "^20.12.12",
    "@types/yargs": "^17.0.33",
    "rimraf": "^5.0.7",
    "ts-node": "^10.9.2",
    "tsx": "^4.10.5",
    "typescript": "^5.4.5"
  }

// File: src/config/app.config.ts

import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

// Handle ESM paths for dotenv
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
// Load .env from project root (assuming config is in src/config)
dotenv.config({ path: path.resolve(__dirname, '../../.env') });


// --- Required API Key ---
/**
 * The Gemini API key.
 * This is a required environment variable.
 * @throws {Error} If the GEMINI_API_KEY environment variable is not set.
 */
export const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

if (!GEMINI_API_KEY) {
    console.error("CRITICAL ERROR: GEMINI_API_KEY environment variable not found.");
    console.log("Please create a .env file in the project root and add your API key:");
    console.log("GEMINI_API_KEY=YOUR_API_KEY_HERE");
    process.exit(1);
}

// --- Selectable Model Name ---
const DEFAULT_GEMINI_MODEL = 'gemini-1.5-flash-latest';
/**
 * The Gemini model name to use.
 * Defaults to 'gemini-1.5-flash-latest' if the GEMINI_MODEL_NAME environment variable is not set.
 */
export const GEMINI_MODEL_NAME = process.env.GEMINI_MODEL_NAME || DEFAULT_GEMINI_MODEL;

// --- Construct Endpoint Dynamically ---
// Base URL structure for the generateContent method
const GEMINI_API_BASE = `https://generativelanguage.googleapis.com/v1beta/models`;
/**
 * The full Gemini API endpoint URL.
 * This is constructed dynamically using the GEMINI_API_BASE and GEMINI_MODEL_NAME.
 */
export const GEMINI_API_ENDPOINT = `${GEMINI_API_BASE}/${GEMINI_MODEL_NAME}:generateContent`; // Construct the full endpoint URL


// --- Log Loaded Configuration ---
// Moved logging to where config is first imported (e.g., gemini.service) to avoid top-level side effects
console.log("Configuration loaded.");
console.log(` > Using Gemini Model: ${GEMINI_MODEL_NAME}`);
console.log(` > Gemini Endpoint: ${GEMINI_API_ENDPOINT}`);

// File: src/gemini/cli/gemini.cli.ts

import yargs, { Argv } from 'yargs';
import { hideBin } from 'yargs/helpers';
import { CliArguments } from '../../shared/types/app.type.js'; // Updated path
import { runCommandLogic } from './gemini.handler.js'; // Updated path
import { EnhancementType } from '../../shared/enums/enhancement.type.js';

const logPrefix = "[GeminiCLI]";

/**
 * Sets up common options (targetPath, prefix) for yargs commands.
 * @param yargsInstance The yargs instance to configure.
 * @returns The yargs instance with the added options.
 */
const setupDefaultCommand = (yargsInstance: Argv<{}>): Argv<{ targetPath: string; prefix: string | undefined }> => {
    return yargsInstance
        .positional('targetPath', {
            describe: 'Target file or directory path',
            type: 'string',
            demandOption: true, // targetPath is always required
        })
        .option('prefix', {
            alias: 'p',
            type: 'string',
            description: 'Optional filename prefix filter for directory processing',
            demandOption: false, // prefix is optional
        });
};

/**
 * Configures and runs the yargs CLI parser.
 * This function defines the commands, options, and logic for the Gemini CLI.
 * @param processArgs The arguments passed to the process, typically process.argv.
 * @returns A Promise that resolves when the CLI execution is complete.
 * @throws An error if argument parsing or command execution fails.
 */
export async function runCli(processArgs: string[]): Promise<void> {
    console.log(`${logPrefix} Initializing...`);

    await yargs(hideBin(processArgs))
        .command( // AddComments
            `${EnhancementType.AddComments} <targetPath>`,
            'Add AI-generated comments to files.',
            setupDefaultCommand, // Use common options setup
            (argv) => runCommandLogic({ ...argv, command: EnhancementType.AddComments } as CliArguments) // Run main logic with command type
        )
        .command( // Analyze
            `${EnhancementType.Analyze} <targetPath>`,
            'Analyze code structure and quality.',
            setupDefaultCommand,
            (argv) => runCommandLogic({ ...argv, command: EnhancementType.Analyze } as CliArguments)
        )
        .command( // Explain
            `${EnhancementType.Explain} <targetPath>`,
            'Explain what the code does.',
            setupDefaultCommand,
            (argv) => runCommandLogic({ ...argv, command: EnhancementType.Explain } as CliArguments)
        )
        .command( // AddPathComment
            `${EnhancementType.AddPathComment} <targetPath>`,
            'Add "// File: <relativePath>" comment header to files.',
            setupDefaultCommand,
            (argv) => runCommandLogic({ ...argv, command: EnhancementType.AddPathComment } as CliArguments)
        )
        .command( // Consolidate
            `${EnhancementType.Consolidate} <targetPath>`,
            'Consolidate code into a single output file (consolidated_output.txt).',
            setupDefaultCommand,
            (argv) => runCommandLogic({ ...argv, command: EnhancementType.Consolidate } as CliArguments)
        )
        .command( // SuggestImprovements
            `${EnhancementType.SuggestImprovements} <targetPath>`,
            'Suggest improvements for the code.',
            setupDefaultCommand,
            (argv) => runCommandLogic({ ...argv, command: EnhancementType.SuggestImprovements } as CliArguments)
        )
        .command( // GenerateDocs
            `${EnhancementType.GenerateDocs} <targetPath>`,
            'Generate Markdown documentation (saves to README.md).',
            setupDefaultCommand,
            (argv) => runCommandLogic({ ...argv, command: EnhancementType.GenerateDocs } as CliArguments)
        )
        .command( // InferFromData
            `${EnhancementType.InferFromData} <targetPath>`,
            'Infer TypeScript interface from a JSON data file.',
            (yargsInstance) => { // Custom setup for this command
                return yargsInstance
                    .positional('targetPath', { // Requires a file path
                        describe: 'Path to the JSON data file',
                        type: 'string',
                        demandOption: true,
                    })
                    .option('interfaceName', { // Requires an interface name
                        alias: 'i',
                        type: 'string',
                        description: 'Name for the generated TypeScript interface',
                        demandOption: true, // Interface name is required for this command
                    });
            },
            (argv) => runCommandLogic({ ...argv, command: EnhancementType.InferFromData } as CliArguments) // Run main logic
        )
        .demandCommand(1, 'Please specify a valid command (action).') // Require at least one command
        .strict() // Report errors for unknown options/commands
        .help() // Enable --help option
        .alias('h', 'help') // Alias -h for help
        .wrap(null) // Adjust terminal width automatically
        .fail((msg, err, yargs) => { // Custom failure handler
            if (err) {
                // Handle unexpected parsing errors
                console.error(`\n${logPrefix} 🚨 An unexpected error occurred during argument parsing:`);
                console.error(err);
                process.exit(1);
            }
            // Handle validation errors (missing command, wrong options, etc.)
            console.error(`\n${logPrefix} ❌ Error: ${msg}\n`);
            yargs.showHelp(); // Show help message on failure
            process.exit(1);
        })
        .parseAsync() // Parse arguments asynchronously
        .catch(error => { // Catch errors from the async parsing or command execution if not caught internally
            console.error(`\n${logPrefix} 🚨 An unexpected critical error occurred during execution:`);
            if (error instanceof Error) {
                console.error(`   Message: ${error.message}`);
                console.error(error.stack); // Log stack trace for critical errors
            } else {
                console.error("   An unknown error object was thrown:", error);
            }
            process.exit(1); // Exit with failure code
        });
}

// File: src/gemini/cli/gemini.handler.ts

import * as fs from 'fs'; // Keep fs for statSync
import * as path from 'path';
import pLimit from 'p-limit';
import { EXCLUDE_FILENAMES } from '../../shared/constants/filesystem.constants.js'; // Updated path
import { inferTypesFromData } from '../../shared/helpers/type-inference.helper.js'; // Updated path
import { CliArguments, FileProcessingResult } from '../../shared/types/app.type.js'; // Updated path
import { EnhancementType } from '../../shared/enums/enhancement.type.js';
import { getConsolidatedSources, getTargetFiles } from '../../shared/utils/filesystem.utils.js';
import { readSingleFile, updateFileContent, writeOutputFile } from '../../shared/utils/file-io.utils.js';
import { enhanceCodeWithGemini, GeminiEnhancementResult } from '../gemini.service.js';

const logPrefix = "[GeminiHandler]";

/**
 * The core application logic. Parses arguments, identifies target files,
 * and executes the requested action (local or via Gemini API).
 * @param {CliArguments} argv The parsed arguments object from yargs.
 * @returns {Promise<void>} A promise that resolves when the command logic is complete.
 */
export async function runCommandLogic(argv: CliArguments): Promise<void> {
    const { command: action, targetPath, prefix, interfaceName } = argv;
    const actionDetails = `${prefix ? ` with prefix: ${prefix}` : ''}${interfaceName ? ` (Interface: ${interfaceName})` : ''}`;
    console.log(`\n${logPrefix} Executing action: ${action} on target: ${targetPath}${actionDetails}`);

    // --- Validate Target Path ---
    let stats: fs.Stats;
    try {
        stats = fs.statSync(targetPath); // Check if the target path exists and get its stats
    } catch (e) {
        console.error(`\n${logPrefix} ❌ Error: Cannot access target path: ${targetPath}. Please ensure it exists.`);
        process.exit(1); // Exit if target path is inaccessible
    }
    // Specific check for InferFromData action, which requires a file
    if (action === EnhancementType.InferFromData && !stats.isFile()) {
        console.error(`\n${logPrefix} ❌ Error: Target path for '${EnhancementType.InferFromData}' must be a file (e.g., JSON).`);
        process.exit(1);
    }

    // --- Classify Action Type ---
    const isModificationAction = [
        EnhancementType.AddComments,
        EnhancementType.AddPathComment,
    ].includes(action);

    const usesGeminiApi = [
        EnhancementType.AddComments,
        EnhancementType.Analyze,
        EnhancementType.Explain,
        EnhancementType.SuggestImprovements,
        EnhancementType.GenerateDocs,
    ].includes(action);

    const isLocalProcessingAction = [
        EnhancementType.Consolidate,
        EnhancementType.InferFromData,
        EnhancementType.AddPathComment,
    ].includes(action);

    try {
        let targetFiles: string[] = []; // Array to hold absolute paths of files to process

        // --- Identify Target Files ---
        if (action === EnhancementType.InferFromData) {
            targetFiles.push(path.resolve(targetPath));
            console.log(`${logPrefix} Target for '${action}' is the single file: ${targetPath}`);
        } else if (stats.isDirectory()) {
            console.log(`${logPrefix} Target is a directory. Finding relevant files...`);
            targetFiles = await getTargetFiles(targetPath, prefix); // Use utility from shared/utils
            if (targetFiles.length === 0) {
                console.log(`\n${logPrefix} No relevant files found matching criteria. Exiting.`);
                return;
            }
            console.log(`${logPrefix} Found ${targetFiles.length} files to process for action '${action}'.`);
        } else if (stats.isFile()) {
            const filename = path.basename(targetPath);
            if (EXCLUDE_FILENAMES.has(filename)) { // Use constant from shared/constants
                console.log(`${logPrefix} Target file ${filename} is excluded by configuration.`);
                return;
            }
            console.log(`${logPrefix} Target is a single file for action '${action}'.`);
            targetFiles.push(path.resolve(targetPath));
        }

        // --- Process Based on Action Type ---

        // A) Actions that modify files and might use Gemini (currently only AddComments)
        if (isModificationAction && action === EnhancementType.AddComments) {
            // --- PARALLEL MODIFICATION FLOW (AddComments) ---
            const concurrencyLimit = 5;
            const limit = pLimit(concurrencyLimit);
            console.log(`\n${logPrefix} Starting PARALLEL modification action '${action}' on ${targetFiles.length} file(s) with concurrency ${concurrencyLimit}...`);

            /**
             * Processes a single file by reading its content, enhancing it with Gemini, and updating the file.
             * @param {string} absoluteFilePath The absolute path to the file.
             * @returns {Promise<FileProcessingResult>} A promise that resolves with the file processing result.
             */
            const fileProcessor = async (absoluteFilePath: string): Promise<FileProcessingResult> => {
                const relativeFilePath = path.relative(process.cwd(), absoluteFilePath).split(path.sep).join('/');
                try {
                    const originalCode = readSingleFile(absoluteFilePath);
                    const result: GeminiEnhancementResult = await enhanceCodeWithGemini(action, originalCode);

                    if (result.type === 'code' && result.content !== null) {
                        if (originalCode.trim() !== result.content.trim()) {
                            const updated = updateFileContent(absoluteFilePath, result.content); // Update the file content
                            return { filePath: relativeFilePath, status: updated ? 'updated' : 'error', message: updated ? undefined : 'File write failed' };
                        } else {
                            console.log(`    ${logPrefix} No changes needed for ${relativeFilePath}.`);
                            return { filePath: relativeFilePath, status: 'unchanged' };
                        }
                    } else if (result.type === 'error') {
                        console.error(`    ${logPrefix} ❌ Gemini failed for ${relativeFilePath}: ${result.content}`);
                        return { filePath: relativeFilePath, status: 'error', message: `Gemini Error: ${result.content}` };
                    } else {
                        console.warn(`    ${logPrefix} ⚠️ Received unexpected result type '${result.type}' or null content (expected 'code') for ${relativeFilePath}.`);
                        return { filePath: relativeFilePath, status: 'error', message: `Unexpected result type/content: ${result.type}` };
                    }
                } catch (fileProcessingError) {
                    console.error(`    ${logPrefix} ❌ Error during Gemini processing for ${relativeFilePath}: ${fileProcessingError instanceof Error ? fileProcessingError.message : fileProcessingError}`);
                    return { filePath: relativeFilePath, status: 'error', message: `File/API Processing Error: ${fileProcessingError instanceof Error ? fileProcessingError.message : "Unknown error"}` };
                }
            };

            const tasks = targetFiles.map(filePath => limit(() => fileProcessor(filePath))); // Create tasks with concurrency limit
            const results: FileProcessingResult[] = await Promise.all(tasks);

            // --- Summarize Parallel Results ---
            let successCount = 0;
            let unchangedCount = 0;
            let errorCount = 0;
            results.forEach(res => {
                switch (res.status) {
                    case 'updated': successCount++; break;
                    case 'unchanged': unchangedCount++; break;
                    case 'error': errorCount++; break;
                }
            });
            console.log("\n--- Parallel Modification Summary ---");
            console.log(`  Action:              ${action}`);
            console.log(`  Total Files Targeted:  ${targetFiles.length}`);
            console.log(`  Successfully Updated:  ${successCount}`);
            console.log(`  No Changes Needed:   ${unchangedCount}`);
            console.log(`  Errors Encountered:    ${errorCount}`);
            console.log("-----------------------------------");
            if (errorCount > 0) process.exitCode = 1;

            // B) Actions that use Gemini but DO NOT modify files (Analyze, Explain, Suggest, GenerateDocs)
        } else if (usesGeminiApi && !isModificationAction) {
            // --- NON-MODIFICATION FLOW using GEMINI ---
            let codeToProcess: string;
            const geminiRequestType = action;

            if (stats.isDirectory() || targetFiles.length > 1) {
                console.log(`\n${logPrefix} Consolidating ${targetFiles.length} file(s) for Gemini action '${action}'...`);
                const consolidationRoot = stats.isDirectory() ? targetPath : path.dirname(targetFiles[0]);
                codeToProcess = await getConsolidatedSources(consolidationRoot, prefix);
            } else if (targetFiles.length === 1) {
                console.log(`\n${logPrefix} Reading single file for Gemini action '${action}'...`);
                codeToProcess = readSingleFile(targetFiles[0]);
            } else {
                console.error(`${logPrefix} Internal Error: No target files identified for Gemini action '${action}'.`);
                process.exitCode = 1;
                return;
            }

            if (codeToProcess.trim() === '') {
                console.warn(`${logPrefix} Warning: Content to send to Gemini for action '${action}' is empty. Skipping API call.`);
                return;
            }

            console.log(`\n${logPrefix} Invoking Gemini service for action: ${geminiRequestType}...`);
            const result: GeminiEnhancementResult = await enhanceCodeWithGemini(geminiRequestType, codeToProcess);

            // --- Handle Gemini Result ---
            if (result.type === 'text' && result.content !== null) {
                if (geminiRequestType === EnhancementType.GenerateDocs) {
                    const outputFileName = 'README.md';
                    const outputFilePath = path.resolve(process.cwd(), outputFileName);
                    console.log(`\n${logPrefix} Attempting to write generated documentation to ${outputFileName}...`);
                    const success = writeOutputFile(outputFilePath, result.content);
                    if (!success) {
                        console.error(`${logPrefix} ❌ Failed to write documentation file.`);
                        process.exitCode = 1;
                    } else {
                        console.log(`\n${logPrefix} ✅ Generated documentation saved to: ${outputFileName}`);
                    }
                } else {
                    console.log(`\n--- Gemini ${geminiRequestType} Result ---`);
                    console.log(result.content);
                    console.log(`--- End ${geminiRequestType} Result ---\n`);
                }
            } else if (result.type === 'error') {
                console.error(`\n${logPrefix} ❌ Gemini service failed: ${result.content ?? 'No specific error message provided.'}`);
                process.exitCode = 1;
            } else {
                console.warn(`${logPrefix} ⚠️ Received unexpected result type '${result.type}' or null content (expected 'text') for ${geminiRequestType} action.`);
                if (result.content) {
                    console.log("--- Unexpected Content Received ---");
                    console.log(result.content.substring(0, 500) + (result.content.length > 500 ? '...' : ''));
                    console.log("----------------------------------");
                }
                process.exitCode = 1;
            }

            // C) Actions processed locally WITHOUT Gemini (Consolidate, InferFromData, AddPathComment)
        } else if (isLocalProcessingAction) {
            // --- LOCAL PROCESSING FLOW ---
            console.log(`\n${logPrefix} Starting local action '${action}'...`);

            // C.1) Consolidate Files
            if (action === EnhancementType.Consolidate) {
                console.log(`${logPrefix} Consolidating ${targetFiles.length} file(s)...`);
                const consolidationRoot = stats.isDirectory() ? targetPath : path.dirname(targetPath);
                console.log(`${logPrefix} Consolidating from root: ${consolidationRoot} ${prefix ? `with prefix '${prefix}'` : ''}...`);
                const consolidatedContent = await getConsolidatedSources(consolidationRoot, prefix);
                const outputFileName = 'consolidated_output.txt';
                const outputFilePath = path.resolve(process.cwd(), outputFileName);
                const success = writeOutputFile(outputFilePath, consolidatedContent);
                if (!success) process.exitCode = 1;
                else console.log(`\n${logPrefix} ✅ You can now find consolidated content in: ${outputFileName}`);

                // C.2) Infer Types from Data File
            } else if (action === EnhancementType.InferFromData) {
                if (!interfaceName) {
                    console.error("[App] Internal Error: Interface name missing for InferFromData.");
                    process.exit(1);
                }
                const dataFilePath = targetFiles[0];
                const relativeDataFilePath = path.relative(process.cwd(), dataFilePath).split(path.sep).join('/');
                console.log(`${logPrefix} Inferring types from data file: ${relativeDataFilePath}`);
                try {
                    const fileContent = readSingleFile(dataFilePath);
                    let data: any;
                    try {
                        data = JSON.parse(fileContent); // Parse JSON content
                    } catch (parseError) {
                        console.error(`${logPrefix} ❌ Error parsing JSON data from ${relativeDataFilePath}: ${parseError instanceof Error ? parseError.message : parseError}`);
                        process.exit(1);
                    }
                    const inferredInterface = inferTypesFromData(interfaceName, data);
                    console.log(`\n--- Inferred Interface: ${interfaceName} ---`);
                    console.log(inferredInterface);
                    console.log(`--- End Interface ---`);
                } catch (inferenceError) {
                    console.error(`${logPrefix} ❌ Error during type inference for ${relativeDataFilePath}: ${inferenceError instanceof Error ? inferenceError.message : inferenceError}`);
                    process.exit(1);
                }

                // C.3) Add Path Comment Header (Local Modification)
            } else if (action === EnhancementType.AddPathComment) {
                console.log(`\n${logPrefix} Starting SEQUENTIAL action '${action}' on ${targetFiles.length} file(s)...`);
                let updatedCount = 0;
                let unchangedCount = 0;
                let skippedCount = 0;
                let errorCount = 0;

                const nonCommentableExtensions = new Set(['.json', '.env']);
                const anyCommentRegex = /^\s*(\/\/.*|#.*)/;

                for (const absoluteFilePath of targetFiles) {
                    const relativeFilePath = path.relative(process.cwd(), absoluteFilePath).split(path.sep).join('/');
                    const fileExtension = path.extname(absoluteFilePath).toLowerCase();

                    if (nonCommentableExtensions.has(fileExtension)) {
                        console.log(`    ${logPrefix} ⏩ Skipping non-commentable file type: ${relativeFilePath}`);
                        skippedCount++;
                        continue;
                    }

                    try {
                        const pathComment = `// File: ${relativeFilePath}`;
                        const originalCode = readSingleFile(absoluteFilePath);
                        const lines = originalCode.split(/\r?\n/);

                        let firstNonBlankLineIndex = -1;
                        let firstNonBlankLine = '';
                        for (let i = 0; i < lines.length; i++) {
                            const trimmedLine = lines[i].trim();
                            if (trimmedLine !== '') {
                                firstNonBlankLineIndex = i;
                                firstNonBlankLine = trimmedLine;
                                break;
                            }

                        let alreadyCorrect = false;
                        if (firstNonBlankLineIndex === 0 && firstNonBlankLine === pathComment) {
                            if (lines.length === 1 || (lines.length > 1 && lines[1].trim() === '')) {
                                alreadyCorrect = true;
                            }

                        if (alreadyCorrect) {
                            console.log(`    ${logPrefix} ✅ No update needed for ${relativeFilePath} (Correct header found)`);
                            unchangedCount++;
                            continue;
                        }

                        console.log(`    ${logPrefix} 🔄 Updating header for ${relativeFilePath}...`);

                        let firstCodeLineIndex = 0;
                        while (firstCodeLineIndex < lines.length) {
                            const lineTrim = lines[firstCodeLineIndex].trim();
                            if (lineTrim === '' || anyCommentRegex.test(lineTrim)) {
                                firstCodeLineIndex++;
                            } else {
                                break;
                            }

                        const codeContentLines = lines.slice(firstCodeLineIndex);
                        const codeContent = codeContentLines.length > 0 ? codeContentLines.join('\n') : '';
                        const newCode = `${pathComment}\n\n${codeContent}`;

                        const updated = updateFileContent(absoluteFilePath, newCode); // Update the file content
                        if (updated) updatedCount++; else errorCount++;

                    } catch (fileProcessingError) {
                        console.error(`    ${logPrefix} ❌ Error during AddPathComment for ${relativeFilePath}: ${fileProcessingError instanceof Error ? fileProcessingError.message : fileProcessingError}`);
                        errorCount++;
                    }
                } // End for loop

                // --- Summarize Sequential Results ---
                console.log("\n--- Sequential Action Summary ---");
                console.log(`  Action:              ${action}`);
                console.log(`  Total Files Targeted:  ${targetFiles.length}`);
                console.log(`  Successfully Updated:  ${updatedCount}`);
                console.log(`  No Changes Needed:   ${unchangedCount}`);
                console.log(`  Skipped (Non-Comment): ${skippedCount}`);
                console.log(`  Errors Encountered:    ${errorCount}`);
                console.log("---------------------------------");
                if (errorCount > 0) process.exitCode = 1;
            }
        } else {
            console.error(`${logPrefix} Internal Error: Action "${action}" was not handled by any processing flow.`);
            process.exit(1);
        }

    } catch (error) {
        console.error(`\n${logPrefix} ❌ An unexpected error occurred during script execution:`);
        if (error instanceof Error) {
            console.error(`   Message: ${error.message}`);
            // console.error(error.stack); // Uncomment for debugging
        } else {
            console.error("   Unknown error object:", error);
        }
        process.exit(1);
    }

    console.log(`\n${logPrefix} Execution finished for action: ${action}.`);
} // End runCommandLogic

// File: src/gemini/gemini.service.ts

import axios, { AxiosError, AxiosResponse } from 'axios';
import { GEMINI_API_ENDPOINT, GEMINI_API_KEY, GEMINI_MODEL_NAME } from '../config/app.config.js';
import { EnhancementType } from '../shared/enums/enhancement.type.js';
import { extractCodeBlock } from './utils/code.extractor.js';

// Log config when service is initialized (better than top-level in config file)
console.log(`[GeminiService] Initialized. Model: ${GEMINI_MODEL_NAME}, Endpoint: ${GEMINI_API_ENDPOINT}`);

/**
 * Represents the result of a Gemini enhancement operation.
 * NOTE: Keeping this interface here as it's tightly coupled to the service's return type.
 * If it needs to be shared more widely, move to shared/types.
 */
export interface GeminiEnhancementResult {
    /** The type of content returned: 'code', 'text', or 'error'. */
    type: 'code' | 'text' | 'error';
    /** The content of the result, which can be a string or null if an error occurred. */
    content: string | null;
}

/**
 * Generates a prompt for the Gemini API based on the enhancement type and code.
 *
 * @param {EnhancementType} enhancement - The type of enhancement to generate the prompt for.
 * @param {string} code - The code to be enhanced.
 * @returns {string} The generated prompt string.
 */
function generatePrompt(enhancement: EnhancementType, code: string): string {
    console.log(`[GeminiService] Generating prompt for enhancement type: ${enhancement}`);
    // ... (rest of generatePrompt code is identical to original)
    switch (enhancement) {
        case EnhancementType.AddComments:
            return `
Review the following TypeScript/JavaScript code. Add comprehensive TSDoc/JSDoc comments /** ... */ for all exported functions, classes, interfaces, types, and significant internal logic. Include @param, @returns, @throws tags where appropriate.
Also add concise inline comments // using // for complex or non-obvious implementation steps within functions or methods.
Ensure existing comments are preserved or improved if necessary.

**CRITICAL INSTRUCTION:** You MUST return the **ENTIRE, COMPLETE, ORIGINAL FILE CONTENT**, including all existing code and comments, with ONLY the new TSDoc/JSDoc and inline comments added or updated as requested. Do NOT omit any part of the original file.
**RESPONSE FORMAT:** Respond ONLY with the full, updated code block itself, enclosed in a single \`\`\`typescript ... \`\`\` or \`\`\`javascript ... \`\`\` block. Do not include ANY introductory text, closing remarks, or explanations outside the code block.

\`\`\`typescript
${code}
\`\`\`
`;
        case EnhancementType.Analyze: // Keep Analyze separate for potentially different focus later
            return `
Analyze the following code. Provide a high-level overview of its purpose, structure, and key components. Identify potential areas for improvement regarding clarity, efficiency, or adherence to best practices, but focus on analysis rather than direct suggestions.

\`\`\`typescript
${code}
\`\`\`
`;
        case EnhancementType.Explain:
            return `
Explain the following TypeScript/JavaScript code in simple terms. Describe its overall purpose, how the main parts work together, and what specific functions or classes are responsible for. Assume the reader has some programming knowledge but may not be familiar with this specific code.

\`\`\`typescript
${code}
\`\`\`
`;
        case EnhancementType.SuggestImprovements: // New
            return `
Act as a senior software engineer performing a code review on the following TypeScript/JavaScript code. Provide specific, actionable suggestions for improvement. Focus on:
1.  **Readability & Clarity:** Can variable names, function names, or structure be improved? Is the logic easy to follow?
2.  **Potential Bugs & Edge Cases:** Are there any obvious logical errors, potential null/undefined issues, or unhandled edge cases?
3.  **Best Practices:** Does the code follow common language idioms and best practices (e.g., error handling, immutability, proper use of async/await)?
4.  **Performance:** Are there any obvious performance bottlenecks or areas where efficiency could be significantly improved? (Avoid premature optimization).
5.  **Maintainability:** How easy would it be to modify or extend this code later? Suggest ways to improve modularity or reduce coupling if applicable.

**RESPONSE FORMAT:** Present your suggestions clearly, perhaps using bullet points or numbered lists, referencing specific lines or sections of the code where possible. Be constructive and explain the reasoning behind each suggestion. Do NOT rewrite the code yourself. Respond only with the suggestions.

\`\`\`typescript
${code}
\`\`\`
`;
        case EnhancementType.GenerateDocs: // New
            return `
Analyze the following TypeScript/JavaScript code and generate documentation in Markdown format suitable for a README file section or a separate documentation file.

The documentation should include:
1.  **Overview:** A brief description of the code's overall purpose and functionality.
2.  **Key Components:** Descriptions of major functions, classes, or modules, including their responsibilities.
3.  **Usage Examples (if applicable):** Show how to use the primary functions or classes with simple examples.
4.  **Inputs/Outputs (if applicable):** Describe important function parameters and return values.

**RESPONSE FORMAT:** Respond ONLY with the generated Markdown content. Do not include any introductory text, closing remarks, or explanations outside the Markdown. Start directly with the Markdown content (e.g., starting with a heading like '## Module Documentation').

\`\`\`typescript
${code}
\`\`\`
`;
        // Note: InferFromData does not use Gemini, so no prompt needed here.
        // Note: AddPathComment and Consolidate do not use Gemini.

        default:
            // Should not happen if using enum correctly, but good practice
            console.warn(`[GeminiService] Unknown enhancement type for prompt generation: ${enhancement}. Using generic prompt.`);
            // Returns a generic prompt as a fallback
            return `Review and provide feedback on the following code:\n\n\`\`\`typescript\n${code}\n\`\`\``;
    }


/**
 * Calls the Gemini API with a given prompt.
 *
 * @param {string} promptText - The prompt text to send to the Gemini API.
 * @returns {Promise<string | null>} A promise that resolves with the response text, or null if an error occurred.
 */
async function callGeminiApi(promptText: string): Promise<string | null> {
    console.log(`[GeminiService] Sending request to Gemini API (${promptText.length} chars)...`);

    const requestData = {
        contents: [{ parts: [{ text: promptText }] }],
        // Optional: Configure generation parameters
        // generationConfig: { ... },
        // Optional: Safety Settings
        // safetySettings: [ ... ]
    };

    const config = {
        headers: { 'Content-Type': 'application/json' },
        params: { key: GEMINI_API_KEY },
        timeout: 120000
    };

    try {
        // Attempt to make the POST request to the Gemini API
        const response: AxiosResponse = await axios.post(GEMINI_API_ENDPOINT, requestData, config);

        // Robustly check for response structure and potential blocks
        const candidate = response.data?.candidates?.[0];

        if (candidate?.finishReason && candidate.finishReason !== "STOP") {
            console.warn(`[GeminiService] Warning: Response generation finished due to reason: ${candidate.finishReason}.`);
            if (candidate.finishReason === "SAFETY") {
                console.error("[GeminiService] ❌ Error: Gemini blocked the response due to safety settings.");
                if (candidate.safetyRatings) {
                    console.error("[GeminiService] Safety Ratings:", JSON.stringify(candidate.safetyRatings, null, 2));
                }
                return null;
            }

        const responseText = candidate?.content?.parts?.[0]?.text;

        if (responseText) {
            console.log(`[GeminiService] Received response (${responseText.trim().length} chars).`);
            return responseText.trim();
        } else {
            console.warn("[GeminiService] Warning: Received response, but no text content found.");
            console.log("[GeminiService] Full Response Data:", JSON.stringify(response.data, null, 2));
            return null;
        }
    } catch (error) {
        console.error("[GeminiService] ❌ Error calling Gemini API:");
        // Cast the error to AxiosError to access response data
        const axiosError = error as AxiosError;
        if (axiosError.response) {
            console.error(`  Status: ${axiosError.response.status}`);
            console.error(`  Data: ${JSON.stringify(axiosError.response.data, null, 2)}`);
            const geminiError = (axiosError.response.data as any)?.error;
            if (geminiError) {
                console.error(`  Gemini Error Code: ${geminiError.code}`);
                console.error(`  Gemini Error Message: ${geminiError.message}`);
                console.error(`  Gemini Error Status: ${geminiError.status}`);
            }
        } else if (axiosError.request) {
            console.error("  Request Error: No response received.", axiosError.code);
        } else {
            console.error('  Setup Error Message:', axiosError.message);
        }
        return null;
    }


/**
 * Enhances the given code with Gemini based on the specified enhancement type.
 *
 * @param {EnhancementType} enhancementType - The type of enhancement to apply.
 * @param {string} code - The code to be enhanced.
 * @returns {Promise<GeminiEnhancementResult>} A promise that resolves with the enhancement result.
 */
export async function enhanceCodeWithGemini(
    enhancementType: EnhancementType,
    code: string
): Promise<GeminiEnhancementResult> {

    // Actions expected to return code
    const expectsCode = [
        EnhancementType.AddComments,
    ].includes(enhancementType);

    // Actions expected to return text
    const expectsText = [
        EnhancementType.Analyze,
        EnhancementType.Explain,
        EnhancementType.SuggestImprovements,
        EnhancementType.GenerateDocs,
    ].includes(enhancementType);

    // Generate the prompt based on the enhancement type and code
    const prompt = generatePrompt(enhancementType, code);
    if (!prompt) {
        return { type: 'error', content: `Failed to generate prompt for action: ${enhancementType}` };
    }

    // Call Gemini API with the generated prompt
    const rawResponse = await callGeminiApi(prompt);

    if (rawResponse === null) {
        return { type: 'error', content: 'Failed to get a valid response from Gemini API.' };
    }

    if (expectsCode) {
        console.log(`[GeminiService] Processing response for ${enhancementType} (expects code)...`);
        // Extract code block from the raw response
        const extractedCode = extractCodeBlock(rawResponse); // Use local utility
        if (extractedCode) {
            console.log("[GeminiService] Code block extracted successfully.");
            return { type: 'code', content: extractedCode };
        } else {
            console.warn(`[GeminiService] ${enhancementType} requested, but couldn't extract a fenced code block.`);
            console.log("--- Full Raw Response (for debugging code extraction) ---");
            console.log(rawResponse);
            console.log("--- End Full Raw Response ---");
            return { type: 'error', content: `Failed to extract valid code block from Gemini response for ${enhancementType}. Raw response logged.` };
        }
    } else if (expectsText) {
        console.log(`[GeminiService] Processing response for ${enhancementType} (expects text)...`);
        // Return the raw response as text
        return { type: 'text', content: rawResponse };
    } else {
        console.error(`[GeminiService] Internal Error: Unhandled enhancement type: ${enhancementType}`);
        return { type: 'error', content: `Unhandled enhancement type: ${enhancementType}` };
    }

// File: src/index.ts

import { runCli } from './gemini/cli/gemini.cli.js';

/**
 * Entry point for the Gemini CLI application.
 * Parses command-line arguments and executes the corresponding Gemini command.
 *
 * @param argv - An array of strings representing the command-line arguments passed to the application.
 *               Typically, this is `process.argv`.
 * @returns void - The function does not return a value directly but initiates the Gemini CLI process.
 */
runCli(process.argv); // Pass command line arguments

// File: src/shared/constants/filesystem.constants.ts

/**
 * Set of file extensions to include during inspection.
 * This set is used to filter files during directory traversal, ensuring that only files with these extensions are processed.
 */
export const INCLUDE_EXTENSIONS: Set<string> = new Set([
    ".ts",
    ".js",
    ".json",
    ".env",
]);

/**
 * Set of directory or file name patterns to exclude during inspection.
 * During directory traversal, any directory or file name matching these patterns will be skipped.
 * This helps to avoid processing unnecessary or irrelevant files.
 */
export const EXCLUDE_PATTERNS: Set<string> = new Set([
    "node_modules",
    "dist",
    "build",
    ".git",
    "coverage",
]);

/**
 * Set of specific filenames to exclude during inspection.
 * This set provides a way to exclude specific files from the inspection process, regardless of their location.
 * This can be useful for excluding configuration files or other files that should not be processed.
 */
export const EXCLUDE_FILENAMES: Set<string> = new Set([
    "package-lock.json",
    "consolidated_sources.ts", // Exclude potential consolidation output if run in src
    "consolidated_output.txt", // Exclude consolidation output
    "code.extractor.ts", // Exclude utility if present
    "README.md", // Exclude generated docs
    "docs.md", // Exclude previously generated docs just in case
]);

// File: src/shared/enums/enhancement.type.ts

/**
 * Enum representing the different types of enhancements that can be applied to code.
 */
export enum EnhancementType {
	/**
	 * Add comments to the code.
	 */
	AddComments = 'AddComments',
	/**
	 * Analyze the code.
	 */
	Analyze = 'Analyze',
	/**
	 * Explain the code.
	 */
	Explain = 'Explain',
	/**
	 * Add path comments to the code.
	 */
	AddPathComment = 'AddPathComment',
	/**
	 * Consolidate the code.
	 */
	Consolidate = 'Consolidate',
	/**
	 * Suggest improvements to the code.
	 */
	SuggestImprovements = 'SuggestImprovements',
	/**
	 * Generate documentation for the code.
	 */
	GenerateDocs = 'GenerateDocs',
	/**
	 * Infer types or structures from provided data.
	 */
	InferFromData = 'InferFromData',
	// Add more types here later
}

/**
 * Checks if a given string is a valid EnhancementType.
 *
 * @param value The string to check.
 * @returns True if the string is a valid EnhancementType, false otherwise.
 */
export function isValidEnhancementType(value: string): value is EnhancementType {
	// Check if the provided value exists in the EnhancementType enum values.
	return Object.values(EnhancementType).includes(value as EnhancementType);
}

// File: src/shared/helpers/filesystem.helper.ts

import { promises as fs } from "fs";
import * as path from "path";

const logPrefix = "[FileSystemHelper]";

/**
 * Recursively traverse a directory and return all file paths, respecting exclusion patterns.
 * @param dir The directory to traverse.
 * @param excludePatterns A set of directory or file names to exclude from the traversal.
 * @param excludeFilenames A set of specific filenames to exclude from the traversal.
 * @returns A promise that resolves to an array of file paths.
 * @throws {Error} If there is an error reading a directory or statting a file. Errors are logged to the console.
 */
export async function getAllFiles(
    dir: string,
    excludePatterns: Set<string>,
    excludeFilenames: Set<string>
): Promise<string[]> {
    let results: string[] = [];
    try {
        const list = await fs.readdir(dir); // Read the contents of the directory
        for (const file of list) {
            const filePath = path.join(dir, file); // Create the full file path

            if (excludePatterns.has(file) || excludeFilenames.has(file)) {
                continue; // Skip files that match the exclude patterns or filenames
            }

            try {
                const stat = await fs.stat(filePath); // Get file/directory stats
                if (stat && stat.isDirectory()) {
                    results = results.concat(await getAllFiles(filePath, excludePatterns, excludeFilenames)); // Recursively call getAllFiles for directories
                } else {
                    results.push(filePath); // Add file path to results
                }
            } catch (statError) {
                console.warn(`${logPrefix} Warning: Could not stat file/dir: ${filePath}. Skipping. Error: ${statError instanceof Error ? statError.message : statError}`);
            }
    } catch (readdirError) {
        console.error(`${logPrefix} Error reading directory: ${dir}. Error: ${readdirError instanceof Error ? readdirError.message : readdirError}`);
    }
    return results;
}

/**
 * Removes leading blank lines and specific comment markers, filters duplicate consecutive lines.
 * @param lines An array of strings representing the lines of a file.
 * @param friendlyPath A file path to use when filtering comment markers.
 * @returns An array of strings representing the filtered lines.
 */
export function filterLines(lines: string[], friendlyPath: string): string[] {
    let startIndex = 0;
    const pathCommentRegex = /^\s*\/\/\s*File:\s*(.+)\s*$/;

    // Remove leading blank lines and path comments.
    while (startIndex < lines.length) {
        const firstLine = lines[startIndex].trim();
        if (firstLine === "") {
            startIndex++;
        } else if (pathCommentRegex.test(firstLine) && firstLine.includes(friendlyPath)) {
            startIndex++;
        } else {
            break;
        }

    const relevantLines = lines.slice(startIndex);
    const filteredLines: string[] = [];
    let prevLineTrimmed: string | null = null;

    // Filter duplicate consecutive lines.
    for (const line of relevantLines) {
        const currentLineTrimmed = line.trim();
        if (currentLineTrimmed !== "" && currentLineTrimmed === prevLineTrimmed) {
            continue; // Skip if the current line is the same as the previous line
        }
        filteredLines.push(line);
        prevLineTrimmed = currentLineTrimmed;
    }
    return filteredLines;
}

// File: src/shared/helpers/type-inference.helper.ts

/**
 * Recursively determines the TypeScript type of a given value.
 * Handles primitive types, arrays, objects, functions, Date instances, and potential date strings.
 *
 * @param {any} value - The value whose type is to be determined.
 * @returns {string} - A string representing the TypeScript type of the given value.
 * @warning The detection of date strings using regex is a heuristic and may misclassify
 *          strings that coincidentally match the ISO 8601 format.
 * @warning This function does not handle circular references in objects. Processing data
 *          with circular references will likely result in a 'Maximum call stack size exceeded' error.
 */
function getType(value: any): string {
    if (value === null) {
        return "null";
    } else if (value === undefined) {
        // Represent undefined explicitly, although less common in JSON
        return "undefined";
    } else if (typeof value === "function") {
        // Functions aren't typical in data structures like JSON, but handle for completeness
        return "Function";
    } else if (Array.isArray(value)) {
        if (value.length === 0) {
            return "Array<any>"; // Or perhaps "unknown[]" or "any[]" based on preference
        }
        // Infer type from elements, handling potentially mixed types
        const uniqueTypes = new Set(value.map((item) => getType(item)));
        // Sort for consistent output if multiple types are present
        return `Array<${Array.from(uniqueTypes).sort().join(" | ")}>`;
    } else if (value instanceof Date) {
        return "Date";
    } else if (typeof value === "string") {
        // Basic check for ISO 8601 Date string format (heuristic)
        // Note: This is a simple heuristic and might misclassify strings that coincidentally match
        if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{1,3})?Z$/.test(value)) {
            return "Date"; // Suggest Date if it looks like an ISO string
        }
        return "string";
    } else if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        // Ensure it's a plain object, not null or an array
        // Potential stack overflow here if obj has circular references
        return getInterface(value);
    }
    // Fallback for primitive types like number, boolean, bigint, symbol
    return typeof value;
}

/**
 * Constructs a TypeScript interface representation (as a string) for a given object.
 * This function recursively calls getType to handle nested structures.
 *
 * @param {object} obj - The object to convert into a TypeScript interface string.
 * @returns {string} - A formatted string representing the TypeScript type interface of the object.
 * @warning This function does not handle circular references. If 'obj' contains circular
 *          references, this may lead to infinite recursion and stack overflow.
 */
function getInterface(obj: object): string {
    const properties = Object.entries(obj).map(
        // Recursively get type for each property value
        ([key, val]) => `  ${key}: ${getType(val)};` // Indent properties // Recursive call
    );
    // Sort properties alphabetically for consistent output
    properties.sort();
    // Format as an inline object type definition
    return `{\n${properties.join("\n")}\n}`;
}

/**
 * Infers TypeScript interface definitions from sample data (e.g., parsed JSON).
 * Handles single objects or arrays of objects, merging properties and types found across all items.
 *
 * @param {string} interfaceName - The desired name for the root TypeScript interface.
 * @param {any} data - The sample data (object or array of objects) to analyze.
 *                     It's assumed this data is JSON-like (no functions, Maps, Sets, etc. handled specifically).
 * @returns {string} - A formatted string representing the generated TypeScript interface.
 * @throws {Error} If the input data is not a single object or an array of objects.
 * @note This service is primarily designed for JSON data. Support for other formats like YAML
 *       would require adding specific parsers.
 * @warning Does not handle circular references within the data structure.
 * @warning Date string detection is based on a simple regex heuristic.
 */
export function inferTypesFromData(interfaceName: string, data: any): string {
    // Validate input data structure
    const isObject = typeof data === 'object' && data !== null && !Array.isArray(data);
    const isArrayOfObjects = Array.isArray(data) && data.every(item => typeof item === 'object' && item !== null);

    if (!isObject && !isArrayOfObjects) {
        throw new Error("Invalid input data: Must be a single object or an array of objects.");
    }
    if (Array.isArray(data) && data.length === 0) {
        console.warn("[Inference] Input data is an empty array. Generating an empty interface.");
        return `interface ${interfaceName} {}\n`;
    }


    // Normalize data to always be an array for consistent processing
    const normalizedData = Array.isArray(data) ? data : [data];
    // Use a Map to store types for each key, preserving insertion order for keys if needed later,
    // but sorting keys alphabetically before output for consistency.
    const typeDefinitions: Map<string, Set<string>> = new Map();

    // Iterate through each item in the normalized data array
    normalizedData.forEach((item) => {
        // Ensure item is a valid object before processing its entries
        if (typeof item === 'object' && item !== null) {
            // Iterate through each key-value pair in the object
            Object.entries(item).forEach(([key, value]) => {
                const valueType = getType(value); // Infer type of the value
                // Initialize the Set for this key if it doesn't exist yet
                if (!typeDefinitions.has(key)) {
                    typeDefinitions.set(key, new Set());
                }
                // Add the inferred type to the Set for this key
                typeDefinitions.get(key)?.add(valueType);
            });
        } else {
            console.warn("[Inference] Skipping non-object item in array:", item);
        }
    });

    // Construct the interface string lines
    const lines: string[] = [`interface ${interfaceName} {`];
    // Get keys and sort them alphabetically for consistent interface property order
    const sortedKeys = Array.from(typeDefinitions.keys()).sort();

    // Add each property definition to the interface lines
    sortedKeys.forEach((key) => {
        const typesSet = typeDefinitions.get(key);
        if (typesSet) {
            // Get unique types, sort them, and join with " | " for union types
            const types = Array.from(typesSet).sort().join(" | ");
            lines.push(`  ${key}: ${types};`); // Add indented property line
        }
    });

    lines.push("}"); // Closing brace for the interface
    return lines.join("\n"); // Join lines into a single string
}

// File: src/shared/types/app.type.ts

import { EnhancementType } from '../enums/enhancement.type.js'; // Use the enum from its new location

/**
 * Represents the command-line arguments passed to the application.
 */
export interface CliArguments {
    /**
     * The enhancement type to apply (e.g., 'add-decorator').
     */
    command: EnhancementType;
    /**
     * The target file or directory path.
     */
    targetPath: string;
    /**
     * An optional prefix to add (e.g., to class names).
     */
    prefix?: string;
    /**
     * An optional interface name (used by the 'InferFromData' command).
     */
    interfaceName?: string; // Specific to InferFromData command
    /**
     * Allows other properties to be passed from yargs.
     */
    [key: string]: unknown; // Allow other yargs properties
    /**
     * Positional arguments passed to the script.
     */
    _: (string | number)[]; // Positional args
    /**
     * The name of the script being executed.
     */
    $0: string;             // Script name
}

/**
 * Represents the result of processing a single file.
 */
export interface FileProcessingResult {
    /**
     * The path to the processed file.
     */
    filePath: string;
    /**
     * The status of the file processing operation.
     *  - 'updated': The file was modified.
     *  - 'unchanged': The file was not modified.
     *  - 'error': An error occurred during processing.
     *  - 'processed': The file was processed, even if no modifications were made.
     */
    status: 'updated' | 'unchanged' | 'error' | 'processed'; // 'processed' could be for non-modification tasks
    /**
     * An optional message providing more detail about the processing result.
     */
    message?: string;
}

// File: src/shared/utils/file-io.utils.ts

import * as fs from 'fs';
import * as path from 'path';

const logPrefix = "[FileIO]";

/**
 * Reads the content of a single file synchronously.
 * @param {string} filePath - The path to the file to read.
 * @returns {string} The content of the file as a string.
 * @throws {Error} If the file does not exist or cannot be read.
 */
export function readSingleFile(filePath: string): string {
    const relativeFilePath = path.relative(process.cwd(), filePath).split(path.sep).join('/');
    try {
        const stats = fs.statSync(filePath);
        if (!stats.isFile()) {
            throw new Error(`Target path is not a file: ${relativeFilePath}`);
        }
        const content = fs.readFileSync(filePath, 'utf8'); // Read the file content in UTF-8 encoding.
        // console.log(`${logPrefix} Read ${content.length} chars from ${relativeFilePath}.`); // Keep logging minimal
        return content;
    } catch (readError) {
        console.error(`${logPrefix} ❌ Error reading file ${relativeFilePath}: ${readError instanceof Error ? readError.message : readError}`);
        throw readError;
    }

/**
 * Updates the content of a file synchronously. Creates parent directory if needed.
 * @param {string} filePath - The path to the file to update.
 * @param {string} newContent - The new content to write to the file.
 * @returns {boolean} True if the file was successfully updated, false otherwise.
 */
export function updateFileContent(filePath: string, newContent: string): boolean {
    const relativeFilePath = path.relative(process.cwd(), filePath).split(path.sep).join('/');
    console.warn(`${logPrefix} ⚠️ Attempting to overwrite ${relativeFilePath}...`);
    try {
        const outputDir = path.dirname(filePath);
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true }); // Create the directory recursively if it doesn't exist.
            console.log(`${logPrefix} Created directory: ${path.relative(process.cwd(), outputDir)}`);
        }
        fs.writeFileSync(filePath, newContent, 'utf8'); // Write the new content to the file in UTF-8 encoding.
        console.log(`${logPrefix} ✅ Successfully updated ${relativeFilePath}.`);
        return true;
    } catch (writeError) {
        console.error(`${logPrefix} ❌ Error writing file ${relativeFilePath}: ${writeError instanceof Error ? writeError.message : writeError}`);
        return false;
    }

/**
 * Writes content to a specified output file. Creates parent directory if needed.
 * @param {string} outputFilePath - The path to the output file.
 * @param {string} content - The content to write to the output file.
 * @returns {boolean} True if the file was successfully written, false otherwise.
 */
export function writeOutputFile(outputFilePath: string, content: string): boolean {
    const relativeOutputPath = path.relative(process.cwd(), outputFilePath).split(path.sep).join('/');
    console.log(`${logPrefix} Writing output to ${relativeOutputPath}...`);
    try {
        const outputDir = path.dirname(outputFilePath);
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true }); // Create the directory recursively if it doesn't exist.
            console.log(`${logPrefix} Created directory: ${path.relative(process.cwd(), outputDir)}`);
        }
        fs.writeFileSync(outputFilePath, content, 'utf8'); // Write the content to the output file in UTF-8 encoding.
        console.log(`${logPrefix} ✅ Successfully wrote ${content.length} characters to ${relativeOutputPath}.`);
        return true;
    } catch (writeError) {
        console.error(`${logPrefix} ❌ Error writing output file ${relativeOutputPath}: ${writeError instanceof Error ? writeError.message : writeError}`);
        return false;
    }

// File: src/shared/utils/filesystem.utils.ts

import { promises as fs } from "fs";
import * as path from "path";
import { INCLUDE_EXTENSIONS, EXCLUDE_PATTERNS, EXCLUDE_FILENAMES } from '../constants/filesystem.constants.js'; // Correct path
import { filterLines, getAllFiles } from "../helpers/filesystem.helper.js"; // Correct path

const logPrefix = "[FileSystemUtil]"; // Renamed prefix for clarity

/**
 * Finds all relevant source files within a directory based on config.
 * @param {string} rootDir - The root directory to search in.
 * @param {string} [filePrefix=""] - An optional file prefix to filter files by.
 * @returns {Promise<string[]>} A promise that resolves to an array of file paths that match the criteria.
 * @throws {Error} If the target directory does not exist or is not accessible.
 */
export async function getTargetFiles(rootDir: string, filePrefix: string = ""): Promise<string[]> {
    console.log(`${logPrefix} Searching for target files in root: ${rootDir}${filePrefix ? `, prefix: '${filePrefix}'` : ''}`);
    let absRoot: string;
    try {
        absRoot = path.resolve(rootDir); // Resolve the root directory to an absolute path.
        const stats = await fs.stat(absRoot);
        if (!stats.isDirectory()) {
            throw new Error(`Target path is not a directory: ${rootDir}`);
        }
        await fs.access(absRoot); // Verify we have access to the directory.
    } catch (error) {
        console.error(`${logPrefix} Error accessing target directory: ${rootDir}`);
        throw new Error(`Failed: Cannot access target directory '${rootDir}'. ${error instanceof Error ? error.message : ''}`);
    }

    const allFiles = await getAllFiles(absRoot, EXCLUDE_PATTERNS, EXCLUDE_FILENAMES); // Use helper
    console.log(`${logPrefix} Found ${allFiles.length} potential files in directory tree.`);

    const targetFiles = allFiles.filter(filePath => {
        const fileName = path.basename(filePath); // Extract the filename from the full path.
        const passesPrefix = !filePrefix || fileName.startsWith(filePrefix); // Check if the filename starts with the given prefix.
        const passesExtension = INCLUDE_EXTENSIONS.has(path.extname(fileName).toLowerCase()); // Check if the file extension is in the allowed list.
        return passesPrefix && passesExtension;
    });

    console.log(`${logPrefix} Found ${targetFiles.length} target files matching criteria.`);
    return targetFiles;
}

/**
 * Consolidates source files from a directory into a single string.
 * @param {string} rootDir - The root directory to consolidate files from.
 * @param {string} [filePrefix=""] - An optional file prefix to filter files by.
 * @returns {Promise<string>} A promise that resolves to a single string containing the concatenated content of all target files.
 * @throws {Error} If the root directory does not exist or is not accessible.
 */
export async function getConsolidatedSources(rootDir: string, filePrefix: string = ""): Promise<string> {
    console.log(`${logPrefix} Starting consolidation for root: ${rootDir}${filePrefix ? `, prefix: '${filePrefix}'` : ''}`);

    const seenFiles: Set<string> = new Set(); // Keep track of files already processed to avoid duplicates.
    const now = new Date().toISOString().slice(0, 19).replace("T", " "); // Get current timestamp for the header.
    let absRoot: string;
    try {
        absRoot = path.resolve(rootDir); // Resolve the root directory to an absolute path.
        await fs.access(absRoot); // Verify we have access to the directory.
    } catch (error) {
        console.error(`${logPrefix} Error accessing root directory: ${rootDir}`);
        throw new Error(`Failed: Cannot access root directory '${rootDir}'. ${error instanceof Error ? error.message : ''}`);
    }

    const header = `// Consolidated sources from: ${absRoot}\n` +
        `// Consolidation timestamp: ${now}\n` +
        `// Tool Name: gemini-poc (inspector module)\n` +
        `// Root Directory: ${absRoot}\n` +
        `// Include Extensions: ${[...INCLUDE_EXTENSIONS].sort().join(", ")}\n` +
        `// Exclude Patterns/Files: ${[...EXCLUDE_PATTERNS, ...EXCLUDE_FILENAMES].sort().join(", ")}\n\n`;

    let outputContent = header;
    const allFiles = await getAllFiles(absRoot, EXCLUDE_PATTERNS, EXCLUDE_FILENAMES); // Use helper
    console.log(`${logPrefix} Found ${allFiles.length} potential files.`);

    for (const filePath of allFiles) {
        const fileName = path.basename(filePath); // Extract the filename from the full path.
        if (filePrefix && !fileName.startsWith(filePrefix)) continue;
        if (!INCLUDE_EXTENSIONS.has(path.extname(fileName).toLowerCase())) continue;

        let canonicalPath: string;
        try {
            canonicalPath = await fs.realpath(filePath); // Get the absolute, canonical path to handle symlinks correctly.
        } catch (realpathError) {
            console.warn(`${logPrefix} Warning: Could not get real path for ${filePath}. Skipping. Error: ${realpathError instanceof Error ? realpathError.message : realpathError}`);
            continue;
        }

        if (seenFiles.has(canonicalPath)) continue; // Skip if already processed.
        seenFiles.add(canonicalPath);

        const relativePath = path.relative(absRoot, canonicalPath); // Get the relative path from the root directory.
        const friendlyPath = relativePath.split(path.sep).join("/"); // Convert the path to a platform-independent format.
        const commentLine = `// File: ${friendlyPath}`;
        console.log(`  ${logPrefix} Processing: ${friendlyPath}`);

        let fileData: string;
        let lines: string[];
        try {
            fileData = await fs.readFile(canonicalPath, "utf-8"); // Read the file content.
            lines = fileData.split(/\r?\n/); // Split the file content into lines.
        } catch (error) {
            console.warn(`  ${logPrefix} Warning: Error reading ${friendlyPath}. Skipping. Error: ${error instanceof Error ? error.message : error}`);
            continue;
        }

        const filtered = filterLines(lines, friendlyPath); // Filter the lines based on exclude patterns.

        if (filtered.length > 0 || fileData.trim() !== '') {
            outputContent += `${commentLine}\n\n`;
            outputContent += filtered.join("\n") + "\n\n";
        } else {
            console.log(`  ${logPrefix} Skipping empty or fully filtered file: ${friendlyPath}`);
        }

    console.log(`${logPrefix} Consolidation complete. Total length: ${outputContent.length} characters.`);
    return outputContent;
}

// File: tsconfig.json

{
  "compilerOptions": {
    "module": "NodeNext", // Specify ESM output compatible with Node.js
    "moduleResolution": "NodeNext", // Use Node's modern module resolution
    "target": "ES2020", // Or newer (ES2020 supports top-level await used in main)
    "outDir": "./dist", // Your existing output directory
    "rootDir": "./src", // Your existing source directory
    "esModuleInterop": true, // Usually helpful for CJS/ESM interop
    "forceConsistentCasingInFileNames": true,
    "strict": true, // Recommended
    "skipLibCheck": true // Often needed for smoother builds
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.spec.ts"]
}


